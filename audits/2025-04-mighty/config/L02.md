# Missing Zero-Output Check on Micro Deposits/Redemptions

## Description

In `LendingPool.sol` both `_deposit` and `_redeem`, the contract computes output amounts using floor division:

```solidity
// _deposit (LendingPool.sol: _line_):  
eTokenAmount = amount.mul(exchangeRate).div(Precision.FACTOR1E18);

// _redeem (LendingPool.sol: _line_):  
underlyingTokenAmount = reserve
    .eTokenToReserveExchangeRate()
    .mul(eTokenAmount)
    .div(Precision.FACTOR1E18);
```

When `amount * rate < 1e18`, the division yields zero. Users can send a tiny deposit or redeem a tiny eToken amount, end up with `eTokenAmount == 0` or `underlyingTokenAmount == 0`, and receive no token.

## Impact

Low severity. No zero check for tiny deposit could be leveraged in a broader griefing or exploitation scenario.

## Recommendation

Add non-zero output guards or minimum thresholds:

```solidity
uint256 eTokenAmount = amount.mul(exchangeRate).div(Precision.FACTOR1E18);
require(eTokenAmount > 0, "DP: amount too small");      // in _deposit

uint256 underlyingTokenAmount =
    reserve.eTokenToReserveExchangeRate()
           .mul(eTokenAmount)
           .div(Precision.FACTOR1E18);
require(underlyingTokenAmount > 0, "RD: amount too small"); // in _redeem
```

