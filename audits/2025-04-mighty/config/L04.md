# `LendingPool.repay()`  adds more credit than what actually used

## Description

In `repay()`, the contract first increases the caller’s credit balance by the full `amount` they passed in, then afterwards clamps `amount` down to the borrower’s outstanding debt. 
However, the reduction of `totalBorrows` and `debtPosition.borrowed` uses the clamped value while the `credit` increase used the uncapped value. In other words, more credit gets added than the amount actually repaid.

Look at code context

```solidity
    function repay(address onBehalfOf, uint256 debtId, uint256 amount)
        external
        notPaused
        nonReentrant
        returns (uint256)
    {//@must be vault
        require(borrowingWhiteList[_msgSender()], Errors.VL_BORROWING_CALLER_NOT_IN_WHITELIST);

        DataTypes.DebtPositionData storage debtPosition = debtPositions[debtId];
        require(_msgSender() == debtPosition.owner, Errors.VL_INVALID_DEBT_OWNER);

        DataTypes.ReserveData storage reserve = getReserve(debtPosition.reserveId);

        // update states
        reserve.updateState(getTreasury());
        updateDebtPosition(debtPosition, reserve.borrowingIndex);

        // only vaultPositionManager contract has credits to borrow tokens
        // when this function is called from the vaultPositionManager contracts,
        // the _msgSender() is the contract's address
        uint256 credit = credits[debtPosition.reserveId][_msgSender()];
        credits[debtPosition.reserveId][_msgSender()] = credit.add(amount);//@audit M admin can set credit to infinity. Causing this to revert and no user can repay

        if (amount > debtPosition.borrowed) {
            amount = debtPosition.borrowed;//@audit M this thing should be move up. Otherwise credit can be inflated to infinity amount
        }
        reserve.totalBorrows = reserve.totalBorrows.sub(amount);
        debtPosition.borrowed = debtPosition.borrowed.sub(amount);

        // Transfer the underlying tokens from the vaultPosition to the eToken contract
        IERC20(reserve.underlyingTokenAddress).safeTransferFrom(_msgSender(), reserve.eTokenAddress, amount);

        reserve.updateInterestRates();

        emit Repay(debtPosition.reserveId, onBehalfOf, _msgSender(), amount);
        return amount;
    }
```

This part of code here clamping amount to debt position to max borrowed value

```solidity
        if (amount > debtPosition.borrowed) {
            amount = debtPosition.borrowed;//@audit M this thing should be move up. Otherwise credit can be inflated to infinity amount
        }
```


## Recommendation

```solidity
+        if (amount > debtPosition.borrowed) {
+            amount = debtPosition.borrowed;//@audit M this thing should be move up. Otherwise credit can be inflated to infinity amount
+        }

        // only vaultPositionManager contract has credits to borrow tokens
        // when this function is called from the vaultPositionManager contracts,
        // the _msgSender() is the contract's address
        uint256 credit = credits[debtPosition.reserveId][_msgSender()];
        credits[debtPosition.reserveId][_msgSender()] = credit.add(amount);//@audit M admin can set credit to infinity. Causing this to revert and no user can repay

-        if (amount > debtPosition.borrowed) {
-            amount = debtPosition.borrowed;//@audit M this thing should be move up. Otherwise credit can be inflated to infinity amount
-        }
        reserve.totalBorrows = reserve.totalBorrows.sub(amount);
        debtPosition.borrowed = debtPosition.borrowed.sub(amount);
```
