# Title

## Summary

- In ReserveLogic.sol, the `utilizationRate` calculation can exceed 100% (i.e., > 1e18) under certain conditions due to rounding and index arithmetic in `borrowedLiquidity`.

## Finding Description

The `utilizationRate` function derives its rate from:

```solidity
(availableLiquidity + borrows)  // total
borrows = latestBorrowingIndex * totalBorrows / borrowingIndex
```

Under precise timing and interest accrual, `latestBorrowingIndex * totalBorrows / borrowingIndex` may exceed the true outstanding borrow amount, making `borrows > total`. Since there is no guard, `utilizationRate = borrows * 1e18 / total` can yield values above 1e18.

## Impact Explanation

- Interest calculations downstream (e.g., in `calculateBorrowingRate`) assume utilization ≤100%; a rate >100% may produce unexpected high interest or revert, potentially locking borrowing or deposit operations.
- Fee minting and capacity checks relying on utilization may misbehave, causing DoS or incorrect state updates.

## Likelihood Explanation

- Low: requires exact alignment of index updates, high-rate settings, and timestamp differences. However, on high-yield assets or with small token amounts, rounding effects are more pronounced.

## Proof of Concept

1. Configure a reserve with non-zero `totalBorrows` and an aggressive interest rate.
2. Let time advance so that `latestBorrowingIndex` grows significantly.
3. Read `utilizationRate`; observe value >1e18.

```js
const rate = await pool.utilizationRateOfReserve(reserveId);
console.log('Utilization:', rate.toString()); // >1e18
```

## Recommendation

- Cap utilization to 100%:

  ```solidity
  if (borrows > total) {
    return Precision.FACTOR1E18;
  }
  ```

- Add a require to enforce `total >= borrows` before division.
- Use `min(borrows * 1e18 / total, 1e18)` when computing the rate.

## Additional Observation
- LendingPool itself does not enforce a minimum or maximum borrowing amount; borrowing limits are managed by ShadowRangeVault on separate accounts.
- As a result, utili­zation rates above 100% allow outstanding debt to exceed expected limits, potentially causing `borrowingRate` to go beyond its configured maximum.
