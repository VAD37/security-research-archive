# When user deposit and send excess twice amount of ETH needed. ETH got Locked in Vault Due to Multiple `pay()` Wrappings

## Summary

When a user overpays ETH to `ShadowRangeVault.openPosition()`, the vault’s two separate `pay()` calls each wrap any attached ETH into WETH. If `msg.value` exceeds the combined WETH requirement, the surplus ETH is converted to WETH and locked in the vault without being refunded.

## Finding Description

The underlying issue in `ShadowRangeVault.sol` is `pay()` function try to wrap ETH balance first:

```solidity
    function pay(address token, address payer, address recipient, uint256 value) internal {
        if (token == WETH9 && address(this).balance >= value) {
            // pay with WETH9
            IWETH9(WETH9).deposit{value: value}(); // wrap only what is needed to pay
            require(IWETH9(WETH9).transfer(recipient, value), "transfer failed");
        } else if (payer == address(this)) {//@never used?
            // pay with tokens already in the contract (for the exact input multihop case)
            TransferHelper.safeTransfer(token, recipient, value);
        } else {
            // pull payment
            TransferHelper.safeTransferFrom(token, payer, recipient, value);
        }
    }
```

Because both `pay()` calls wrap from the same `msg.value`, a user sending more ETH than needed can have their excess ETH consumed and converted into WETH on the second pay(), leaving no ETH to refund.

```solidity
// 1. Pull principal from user (wraps ETH→WETH if token==WETH)
if (params.amount0Principal > 0) {
    pay(token0, msg.sender, address(this), params.amount0Principal);
}
if (params.amount1Principal > 0) {
    pay(token1, msg.sender, address(this), params.amount1Principal);
}

// … borrowing logic …

// 2. Forward (principal + borrowed) to the position contract
//    This second pay() again wraps from msg.value if token==WETH
if (params.amount0Principal > 0 || params.amount0Borrow > 0) {
    pay(token0, address(this), positionInfo.positionAddress,
        params.amount0Principal + params.amount0Borrow);
}
if (params.amount1Principal > 0 || params.amount1Borrow > 0) {
    pay(token1, address(this), positionInfo.positionAddress,
        params.amount1Principal + params.amount1Borrow);
}

// … rest of logic …

// 3. Refund any leftover ETH
if (msg.value > 0) {
    refundETH();
}
```

## Impact Explanation

High: Surplus ETH is irrecoverably locked as WETH in the vault. Overpaying users lose funds silently.

## Likelihood Explanation

Medium: While GUIs typically guide exact amounts, advanced users or scripts may send custom values and accidentally overpay. The issue is silent—transactions succeed but lock funds—making it hard to detect until value is lost.

## Proof of Concept

See `testOpenPositionSendTooMuchETH_H02` in `test/debug.t.sol`:

1. The test sends 300 ETH when only 100 ETH is needed.
2. Open Vault Position with 100 ETH as principle but send 300 ETH.
3. It expected to get refund 200 ETH and get position of 50 ETH-50 USDC.e on Uniswap
4. Only 100 ETH is returned; the remaining 100 ETH is wrapped into WETH and retained by `vault`

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "contracts/AddressRegistry.sol";
import "contracts/mock/MockWETH9.sol";
import "contracts/shadow/ShadowRangeVault.sol";
import "contracts/shadow/ShadowRangePositionImpl.sol";
import "contracts/shadow/ShadowPositionValueCalculator.sol";
import "contracts/VaultRegistry.sol"; //vault factory

import "contracts/lendingpool/LendingPool.sol";
import {PrimaryPriceOracle} from "contracts/PrimaryPriceOracle.sol";
//IShadowSwapRouter == uniswapRouterV3

contract DebugTest is Test {
    MockWETH9 public wS = MockWETH9(payable(0x039e2fB66102314Ce7b64Ce5Ce3E5183bc94aD38));
    ERC20 public wETH = ERC20(0x50c42dEAcD8Fc9773493ED674b675bE577f2634b); //MintedERC20 have burn function
    ERC20 public USDC = ERC20(0x29219dd400f2Bf60E5a23d13Be72B486D4038894); //e6
    ERC20 public USDT = ERC20(0x6047828dc181963ba44974801FF68e538dA5eaF9);

    AddressRegistry public addressRegistry;
    VaultRegistry public vaultRegistry;
    LendingPool public lendingPool;
    PrimaryPriceOracle public primaryPriceOracle;
    //IShadowSwapRouter public shadowSwapRouter;
    ShadowPositionValueCalculator public shadowPositionValueCalculator;

    ShadowRangeVault public vault1; // wS-USDC.e-50
    ShadowRangeVault public vault2; // wS-WETH-50
    ShadowRangeVault public vault3; // USDC.e-USDT-1

    address liquidator = makeAddr("liquidator");

    address treasuryAddress = 0x57C41F44aA5b0793a3fE0195F6c879892494109F;
    address positionManagerV3 = 0x12E66C8F215DdD5d48d150c8f46aD0c6fB0F4406;
    address swapRouter = 0x5543c6176FEb9B4b179078205d7C29EEa2e2d695;
    address swapxPositionManager = 0xd82Fe82244ad01AaD671576202F9b46b76fAdFE2;
    address swapXswapRouter = 0x037c162092881A249DC347D40Eb84438e3457c02;

    function setUp() public {
        vm.createSelectFork(
            "https://rpc.ankr.com/sonic_mainnet/95e6b7b3769824dfa420ef460b5fd940bff206ca48caea572c3a9198f245bbb5",
            21529000
        ); // Sonic/Phantom Mainnet Fork Block 21529000

        address admin = address(this);

        addressRegistry = new AddressRegistry(address(wS));
        addressRegistry.setAddress(1, address(wS)); // Set WETH9 address in AddressRegistry

        vaultRegistry = new VaultRegistry(address(addressRegistry));
        addressRegistry.setAddress(10, address(vaultRegistry)); // Set VaultRegistry address in AddressRegistry
        lendingPool = new LendingPool();
        lendingPool.initialize(address(addressRegistry), address(wS));
        addressRegistry.setAddress(9, address(lendingPool)); // Set LendingPool address in AddressRegistry

        primaryPriceOracle = new PrimaryPriceOracle();
        address[] memory initialTokens = new address[](4);
        bytes32[] memory priceIds = new bytes32[](4);
        initialTokens[0] = 0x039e2fB66102314Ce7b64Ce5Ce3E5183bc94aD38; // wS
        initialTokens[1] = 0x50c42dEAcD8Fc9773493ED674b675bE577f2634b; // wETH
        initialTokens[2] = 0x29219dd400f2Bf60E5a23d13Be72B486D4038894; // USDC.e
        initialTokens[3] = 0x6047828dc181963ba44974801FF68e538dA5eaF9; // USDT
        priceIds[0] = 0xf490b178d0c85683b7a0f2388b40af2e6f7c90cbe0f96b31f315f08d0e5a2d6d; // wS price id
        priceIds[1] = 0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace; // wETH price id
        priceIds[2] = 0xeaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a; // USDC.e price id
        priceIds[3] = 0x2b89b9dc8fdf9f34709a5b106b472f0f39bb6ca9ce04b0fd7f2e971688e2e53b; // USDT price id

        primaryPriceOracle.initialize(
            0x2880aB155794e7179c9eE2e38200202908C17B43, // Pyth address on Phantom
            admin, // OracleManager address
            initialTokens, // Initial tokens (empty for now)
            priceIds // Initial price ids (empty for now)
        );
        addressRegistry.setAddress(100, address(primaryPriceOracle)); // Set PrimaryPriceOracle address in AddressRegistry

        addressRegistry.setAddress(11, address(treasuryAddress)); // Set Treasury address in AddressRegistry
        addressRegistry.setAddress(12, address(treasuryAddress)); // Set Performance Fee Recipient address in AddressRegistry
        addressRegistry.setAddress(13, address(treasuryAddress)); // Set Liquidation Fee Recipient address in AddressRegistry
        addressRegistry.setAddress(300, address(swapRouter)); // Set ShadowSwapRouter address in AddressRegistry
        addressRegistry.setAddress(301, address(positionManagerV3)); // Set ShadowNonFungiblePositionManager address in AddressRegistry
        shadowPositionValueCalculator = new ShadowPositionValueCalculator();
        addressRegistry.setAddress(302, address(shadowPositionValueCalculator)); // Set ShadowPositionValueCalculator address in AddressRegistry

        //Lending Pool config
        lendingPool.initReserve(0x039e2fB66102314Ce7b64Ce5Ce3E5183bc94aD38); // wS
        lendingPool.initReserve(0x50c42dEAcD8Fc9773493ED674b675bE577f2634b); // wETH
        lendingPool.initReserve(0x29219dd400f2Bf60E5a23d13Be72B486D4038894); // USDC.e
        lendingPool.initReserve(0x6047828dc181963ba44974801FF68e538dA5eaF9); // USDT
        //create vaults
        vault1 = new ShadowRangeVault();
        vault1.initialize(
            address(addressRegistry),
            address(vaultRegistry),
            0x324963c267C354c7660Ce8CA3F5f167E05649970, //Pool: wS/USDC.e , from Gauge 0xe879d0e44e6873cf4ab71686055a4f6817685f02
            address(new ShadowRangePositionImpl())
        );
        vault1.setLiquidationFeeParams(500, 5000);
        vault1.setOpenLiquidationEnabled(true);
        vault1.setPerformanceFee(1500);
        vault1.setMinPositionSize(1 * 10 ** 8); // 1 USDC.e
        vault1.setShadowGauge(0xe879d0E44e6873cf4ab71686055a4f6817685f02);
        vaultRegistry.newVault(address(vault1)); //vaultId = 1
        lendingPool.setCreditsOfVault(1, 1, type(uint256).max); // wS
        lendingPool.setCreditsOfVault(1, 3, type(uint256).max); // USDC.e

        skip(30); // skip 30 seconds to avoid block.timestamp = 0
    }

    function testOpenPositionSendTooMuchETH_H02() public {
        // Test case for opening a position with too much ETH sent. Over twice amount of principle
        address exploiter = makeAddr("Exploiter");
        vm.startPrank(exploiter);
        uint256 totalSonic = 300 ether; // Amount of Sonic sent
        deal(exploiter, totalSonic);

        // Open position with too much ETH sent
        IVault.OpenPositionParams memory params = IVault.OpenPositionParams({
            amount0Principal: 100 ether, // Amount of Sonic sent
            amount1Principal: 0, // Amount of USDC.e sent
            amount0Borrow: 0,
            amount1Borrow: 0,
            amount0SwapNeededForPosition: 0,
            amount1SwapNeededForPosition: 0,
            amount0Desired: 100 ether, // Amount of Sonic desired
            amount1Desired: 0, // Amount of USDC.e desired
            deadline: block.timestamp + 60 minutes,
            tickLower: -50000,
            tickUpper: 50000,
            ul: -50000,
            ll: 50000
        });

        console.log("Before Vault Sonic balance: %e", address(vault1).balance);
        console.log("Before user Sonic balance: %e", address(exploiter).balance);

        console.log("Open Sonic Position with: %e SONIC", totalSonic);
        vault1.openPosition{value: totalSonic}(params);
        
        // It is expected to get refund 200 wS back
        // instead we get get only 100 Sonic, 100 wSonic is stucked in the vault
        console.log("wS stuck on Vault: %e", wS.balanceOf(address(vault1)));
        console.log("After user Sonic balance: %e", address(exploiter).balance);

        uint256 refundAmount = 100 ether;
        // assertEq(address(exploiter).balance, refundAmount, "Refund amount is not correct");
    }

    function debugReserve(uint256 reserveId) public view {
        console.log("----Reserve Status [%d]----", reserveId);
        // console.log("%s Underlying Token Address", lendingPool.getUnderlyingTokenAddress(reserveId));
        // console.log("%s eToken Address", lendingPool.getETokenAddress(reserveId));
        // console.log("%s Staking Address", lendingPool.getStakingAddress(reserveId));
        console.log("%e Total Liquidity", lendingPool.totalLiquidityOfReserve(reserveId));
        console.log("%e Total Borrows", lendingPool.totalBorrowsOfReserve(reserveId));
        console.log("%e Exchange Rate", lendingPool.exchangeRateOfReserve(reserveId));
        console.log("%e Utilization Rate", lendingPool.utilizationRateOfReserve(reserveId));
        console.log("%e Borrowing Rate", lendingPool.borrowingRateOfReserve(reserveId));
        // Additional reserve properties (like fee rate, booleans, update timestamp, borrowing index)
        // would need new getter functions in LendingPool.
        console.log("%e BorrowingIndex", lendingPool.latestBorrowingIndex(reserveId));
    }
}

```

## Recommendation

Second payment is pulling cash from borrowing ERC20 into Position.
So this second `pay()` call should not try to wrap ETH from user. Since they already pay.
Move `if payer  == address(this)` up. Maybe not sure.

```solidity
        if (payer == address(this)) {
            // pay with tokens already in the contract (for the exact input multihop case)
            TransferHelper.safeTransfer(token, recipient, value);
        else if (token == WETH9 && address(this).balance >= value) {
            // pay with WETH9
            IWETH9(WETH9).deposit{value: value}(); // wrap only what is needed to pay
            require(IWETH9(WETH9).transfer(recipient, value), "transfer failed");
        } else {
            // pull payment
            TransferHelper.safeTransferFrom(token, payer, recipient, value);
        }
```
