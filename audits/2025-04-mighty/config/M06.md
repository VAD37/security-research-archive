# Reliance on Untrusted slot0() Price Enables Forced Liquidation

## Summary

Directly sourcing price from `IShadowV3Pool.slot0()` allows an attacker to manipulate the spot price on Uniswap V3 and artificially inflate the vault’s debt ratio, triggering forced liquidations of otherwise healthy positions.

## Finding Description

The `ShadowPositionValueCalculator` reads the current sqrt price via:

```solidity
(uint160 sqrtPriceX96,,,,,,) = v3Pool.slot0();
```

This value is used to calculate token amounts and USD values for positions:

```solidity
(uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(
    sqrtPriceX96, ...
);
uint256 positionValueUSD = amount0 * getTokenPrice(token0) + amount1 * getTokenPrice(token1);
```

Because `slot0()` reflects the instantaneous, manipulable pool price, an attacker can perform a large swap or flash loan to skew this reading. The malicious price propagates through `getPositionValue()`, inflating the debt ratio calculation in `getDebtRatio()`, and crosses the 80% liquidation threshold, even for healthy collateral.

## Impact Explanation

Forced liquidations enable attackers to repay underpriced debt and seize collateral at a discount. Users suffer capital loss, the vault may face bad debt if repayments don’t cover loans, and contract reputation is damaged as on-chain oracle integrity is undermined.

## Likelihood Explanation

High. Uniswap V3 pools can be manipulated with moderate capital or flash loans, particularly in low-liquidity or edge-tick scenarios. Any position near the liquidation boundary is immediately exploitable.

## Proof of Concept

1. User opens a vault position at 75% debt ratio.
2. Attacker executes a flash swap on the corresponding Uniswap V3 pool to skew the spot price by ±10%.
3. Vault calls `getDebtRatio()`, which now returns >80% due to manipulated price.
4. Attacker invokes `liquidatePosition()`, repays the underpriced debt, and captures collateral profitably.

## Recommendation

**Adopt TWAP**: Use Uniswap V3’s `observe()` and OracleLibrary to compute a time-weighted price over a secure window:

```solidity
uint32[] memory secondsAgos = new uint32[](2);
secondsAgos[0] = 30; // 30 seconds ago
secondsAgos[1] = 0;
(int56[] memory tickCumulatives, ) = v3Pool.observe(secondsAgos);
int56 tickDelta = tickCumulatives[1] - tickCumulatives[0];
int24 averageTick = int24(tickDelta / 30);
uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(averageTick);
```

**Cross-Check Oracles**: Validate against a robust off-chain feed (Chainlink, Pyth) and enforce deviation checks to reject any single-block price outliers.
**Emergency Safeguards**: Pause liquidations if price deviation exceeds configurable thresholds within a block.
