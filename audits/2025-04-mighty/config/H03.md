# Incorrect Treasury Fee Minting Dilutes Protocol Revenue

## Summary

`_mintToTreasury()` is designed to capture the protocol’s performance‑fee by minting eTokens (shares of the `LendingPool`) to the treasury.
Because the function uses the pre‑mint exchange rate, it ignores the dilution caused by the mint itself, so the treasury receives far fewer shares than the fee’s true value.

A quick POC check with `reserveFeeRate = 100 %` shows some of the accrued interest going to users instead of the treasury.

## Finding Description

The fee is converted to eTokens using the **pre‑mint** exchange rate, which does not account for the dilution introduced by minting new shares. Immediately after the mint, the exchange rate falls, so the treasury receives fewer shares than the fee is worth.

This report does not dive into the full algebra; the deviation is made evident by the PoC, where the treasury’s payout is noticeably short. See the PoC for exact figures.

Looking at how performance fee is taken from interest received by pool.

```solidity
    function _mintToTreasury(
        DataTypes.ReserveData storage reserve,
        uint256 previousDebt,
        uint256 currentDebt,
        address treasury
    ) internal {
        uint256 feeRate = reserve.reserveFeeRate;// 15.00%

        if (feeRate == 0) {
            return;
        }

        //debt accrued is the current debt minus the debt at the last update
        uint256 totalDebtAccrued = currentDebt.sub(previousDebt);//e6 token rounded down too much
        uint256 reserveValueAccrued = totalDebtAccrued.mul(feeRate).div(Constants.PERCENT_100);// =*1500 / 10000
        // reserve value to eTokens
        uint256 exchangeRate = reserveToETokenExchangeRate(reserve);//this rate < 1 . also depend on asset/token decimals
        uint256 feeInEToken = reserveValueAccrued.mul(exchangeRate).div(Precision.FACTOR1E18);

        if (feeInEToken != 0) {
            IExtraInterestBearingToken(reserve.eTokenAddress).mintToTreasury(treasury, feeInEToken);
        }//@audit minting fee seem not correct. It devalue from total share
    }
```

What minting here trying to do is:

- Goal: Mint pool shares for the treasury equal to the protocol fee.

- Analogy: Similar to LendingPool.deposit() or an ERC‑4626 deposit, which adds both assets and shares, preserving the exchange rate.

- Problem: Here, shares are minted without adding assets, so the exchange rate drops. The pre‑mint calculation is now wrong, and the treasury is under‑compensated.

What minting should do here is figure out way to mint share amount that exactly offsets the dilution

```solidity
// F: Fee generated
// S: Supply, A: Asset
uint256 shares = reserveValueAccrued     // F
                 * totalShares()         // S
                 / (totalAssets() - reserveValueAccrued); // A - F
eToken.mintToTreasury(treasury, shares);
```

## Impact Explanation

High: Huge chunk of fee is lost to developer

## Likelihood Explanation

High: It happen with any fee rate

## Proof of Concept

POC do the following:

- set reserve treasury fee from interest rate to 100%
- deposit 2000 USDC and borrow out all of them
- utilization = 100%. borrow rate is 150% APR
- after 1 year, 2000 USDC result in 7249 USDC in total liquidity (original deposit + interest). (7249$ because Compounded interest fomular with Taylor Series n=3)
- repay and minting fee eToken to treasury
- Treasury burn all eToken and redeem 3053 USDC
- User redeem and got 4204 USDC. >2000$ profit
- There is mismatch in fee received by treasury. It should be 5249$ not 3053$ when performance fee is 100%

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "contracts/AddressRegistry.sol";
import "contracts/mock/MockWETH9.sol";
import "contracts/shadow/ShadowRangeVault.sol";
import "contracts/shadow/ShadowRangePositionImpl.sol";
import "contracts/shadow/ShadowPositionValueCalculator.sol";
import "contracts/VaultRegistry.sol"; //vault factory

import "contracts/lendingpool/LendingPool.sol";
import {PrimaryPriceOracle} from "contracts/PrimaryPriceOracle.sol";
//IShadowSwapRouter == uniswapRouterV3

contract DebugTest is Test {
    MockWETH9 public wS = MockWETH9(payable(0x039e2fB66102314Ce7b64Ce5Ce3E5183bc94aD38));
    ERC20 public wETH = ERC20(0x50c42dEAcD8Fc9773493ED674b675bE577f2634b); //MintedERC20 have burn function
    ERC20 public USDC = ERC20(0x29219dd400f2Bf60E5a23d13Be72B486D4038894); //e6
    ERC20 public USDT = ERC20(0x6047828dc181963ba44974801FF68e538dA5eaF9);

    AddressRegistry public addressRegistry;
    VaultRegistry public vaultRegistry;
    LendingPool public lendingPool;
    PrimaryPriceOracle public primaryPriceOracle;
    //IShadowSwapRouter public shadowSwapRouter;
    ShadowPositionValueCalculator public shadowPositionValueCalculator;

    ShadowRangeVault public vault1; // wS-USDC.e-50
    ShadowRangeVault public vault2; // wS-WETH-50
    ShadowRangeVault public vault3; // USDC.e-USDT-1

    address liquidator = makeAddr("liquidator");

    address treasuryAddress = 0x57C41F44aA5b0793a3fE0195F6c879892494109F;
    address positionManagerV3 = 0x12E66C8F215DdD5d48d150c8f46aD0c6fB0F4406;
    address swapRouter = 0x5543c6176FEb9B4b179078205d7C29EEa2e2d695;
    address swapxPositionManager = 0xd82Fe82244ad01AaD671576202F9b46b76fAdFE2;
    address swapXswapRouter = 0x037c162092881A249DC347D40Eb84438e3457c02;

    function setUp() public {
        vm.createSelectFork(
            "https://rpc.ankr.com/sonic_mainnet/95e6b7b3769824dfa420ef460b5fd940bff206ca48caea572c3a9198f245bbb5",
            21529000
        ); // Sonic/Phantom Mainnet Fork Block 21529000

        address admin = address(this);

        addressRegistry = new AddressRegistry(address(wS));
        addressRegistry.setAddress(1, address(wS)); // Set WETH9 address in AddressRegistry

        vaultRegistry = new VaultRegistry(address(addressRegistry));
        addressRegistry.setAddress(10, address(vaultRegistry)); // Set VaultRegistry address in AddressRegistry
        lendingPool = new LendingPool();
        lendingPool.initialize(address(addressRegistry), address(wS));
        addressRegistry.setAddress(9, address(lendingPool)); // Set LendingPool address in AddressRegistry

        primaryPriceOracle = new PrimaryPriceOracle();
        address[] memory initialTokens = new address[](4);
        bytes32[] memory priceIds = new bytes32[](4);
        initialTokens[0] = 0x039e2fB66102314Ce7b64Ce5Ce3E5183bc94aD38; // wS
        initialTokens[1] = 0x50c42dEAcD8Fc9773493ED674b675bE577f2634b; // wETH
        initialTokens[2] = 0x29219dd400f2Bf60E5a23d13Be72B486D4038894; // USDC.e
        initialTokens[3] = 0x6047828dc181963ba44974801FF68e538dA5eaF9; // USDT
        priceIds[0] = 0xf490b178d0c85683b7a0f2388b40af2e6f7c90cbe0f96b31f315f08d0e5a2d6d; // wS price id
        priceIds[1] = 0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace; // wETH price id
        priceIds[2] = 0xeaa020c61cc479712813461ce153894a96a6c00b21ed0cfc2798d1f9a9e9c94a; // USDC.e price id
        priceIds[3] = 0x2b89b9dc8fdf9f34709a5b106b472f0f39bb6ca9ce04b0fd7f2e971688e2e53b; // USDT price id

        primaryPriceOracle.initialize(
            0x2880aB155794e7179c9eE2e38200202908C17B43, // Pyth address on Phantom
            admin, // OracleManager address
            initialTokens, // Initial tokens (empty for now)
            priceIds // Initial price ids (empty for now)
        );
        addressRegistry.setAddress(100, address(primaryPriceOracle)); // Set PrimaryPriceOracle address in AddressRegistry

        addressRegistry.setAddress(11, address(treasuryAddress)); // Set Treasury address in AddressRegistry
        addressRegistry.setAddress(12, address(treasuryAddress)); // Set Performance Fee Recipient address in AddressRegistry
        addressRegistry.setAddress(13, address(treasuryAddress)); // Set Liquidation Fee Recipient address in AddressRegistry
        addressRegistry.setAddress(300, address(swapRouter)); // Set ShadowSwapRouter address in AddressRegistry
        addressRegistry.setAddress(301, address(positionManagerV3)); // Set ShadowNonFungiblePositionManager address in AddressRegistry
        shadowPositionValueCalculator = new ShadowPositionValueCalculator();
        addressRegistry.setAddress(302, address(shadowPositionValueCalculator)); // Set ShadowPositionValueCalculator address in AddressRegistry

        //Lending Pool config
        lendingPool.initReserve(0x039e2fB66102314Ce7b64Ce5Ce3E5183bc94aD38); // wS
        lendingPool.initReserve(0x50c42dEAcD8Fc9773493ED674b675bE577f2634b); // wETH
        lendingPool.initReserve(0x29219dd400f2Bf60E5a23d13Be72B486D4038894); // USDC.e
        lendingPool.initReserve(0x6047828dc181963ba44974801FF68e538dA5eaF9); // USDT
        //create vaults
        vault1 = new ShadowRangeVault();
        vault1.initialize(
            address(addressRegistry),
            address(vaultRegistry),
            0x324963c267C354c7660Ce8CA3F5f167E05649970, //Pool: wS/USDC.e , from Gauge 0xe879d0e44e6873cf4ab71686055a4f6817685f02
            address(new ShadowRangePositionImpl())
        );
        vault1.setLiquidationFeeParams(500, 5000);
        vault1.setOpenLiquidationEnabled(true);
        vault1.setPerformanceFee(1500);
        vault1.setMinPositionSize(1 * 10 ** 8); // 1 USDC.e
        vault1.setShadowGauge(0xe879d0E44e6873cf4ab71686055a4f6817685f02);
        vault1.setReserveIds(1, 3); // wS, USDC

        uint256 vaultId1 = vaultRegistry.newVault(address(vault1));
        lendingPool.enableVaultToBorrow(vaultId1); //vaultId 1
        lendingPool.setCreditsOfVault(vaultId1, 1, type(uint256).max); // wS
        lendingPool.setCreditsOfVault(vaultId1, 3, type(uint256).max); // USDC.e

        skip(30); // skip 30 seconds to avoid block.timestamp = 0
    }

    function testMintingFeeDevalueShare() public {
        //admin config. Fix vault credit
        lendingPool.setCreditsOfVault(1, 1, type(uint256).max / 2); // wS
        lendingPool.setCreditsOfVault(1, 3, type(uint256).max / 2); // USDC.e
        lendingPool.setReserveFeeRate(1,10000);// fee 50% from interest
        lendingPool.setReserveFeeRate(3,10000);// fee 50% from interest

        // Test case for minting fee devaluing shares
        // User deposits and borrowing USDC.e and wSonic
        address user = makeAddr("User");
        vm.startPrank(user);
        deal(address(wS), user, 10000 ether);
        deal(address(USDC), user, 20000e6);
        wS.approve(address(lendingPool), type(uint256).max);
        USDC.approve(address(lendingPool), type(uint256).max);
        uint256 tokenOut1 = lendingPool.deposit(1, 1000e18, user, 0);
        uint256 tokenOut2 = lendingPool.deposit(3, 2000e6, user, 0);
        debugReserve(1);
        debugReserve(3);

        console.log("-User deposit wSonic to lendingPool: %e", tokenOut1);
        console.log("-User deposit USDC.e to lendingPool: %e", tokenOut2);
        // User borrows USDC.e and wSonic

        wS.approve(address(vault1), type(uint256).max);
        USDC.approve(address(vault1), type(uint256).max);
        IVault.OpenPositionParams memory params = IVault.OpenPositionParams({
            amount0Principal: 0, // Amount of Sonic sent
            amount1Principal: 10000e6, // Amount of USDC.e sent
            amount0Borrow: 1000 ether,
            amount1Borrow: 2000e6, //debt 2478$
            amount0SwapNeededForPosition: 0,
            amount1SwapNeededForPosition: 0,
            amount0Desired: 10000 ether, // Amount of Sonic desired
            amount1Desired: 0, // Amount of USDC.e desired
            deadline: block.timestamp + 60 minutes,
            tickLower: -50000,
            tickUpper: 50000,
            ul: -50000,
            ll: 50000
        });
        console.log("-Open Position");
        uint256 positionId = vault1.nextPositionID();
        vault1.openPosition(params);

        // utilization rate should be 100% now
        debugReserve(1);
        debugReserve(3);

        //wait few days
        console.log("-wait a few days and refresh interest rate");
        skip(365 days);
        debugReserve(1);
        debugReserve(3);
        //repay
        (uint256 amount0Debt, uint256 amount1Debt) = vault1.getPositionDebt(positionId);
        console.log("-Debt amount0: %e", amount0Debt);
        console.log("-Debt amount1: %e", amount1Debt);
        ERC20 eToken1 = ERC20(lendingPool.getETokenAddress(1));
        ERC20 eToken3 = ERC20(lendingPool.getETokenAddress(3));
        // eToken1.approve(address(vault1), type(uint256).max);
        // eToken3.approve(address(vault1), type(uint256).max);
        vault1.repayExact(positionId, amount0Debt, amount1Debt);
        
        console.log("-User eToken balance: %e", eToken1.balanceOf(user));
        console.log("-User eToken balance: %e", eToken3.balanceOf(user));
        console.log("-Treasury eToken balance: %e", eToken1.balanceOf(treasuryAddress));
        console.log("-Treasury eToken balance: %e", eToken3.balanceOf(treasuryAddress));

        debugReserve(1);
        debugReserve(3);

        //No more borrowing. Treasury and user can now safely withdraw everything.
        //Issue: total eToken * exchangeRate > total liquidity. Treasury mint token without reserve backing
        //Not enough liquidity despite all debt have been repay for everyone to withdraw.
        
        
        vm.startPrank(treasuryAddress);
        eToken3.approve(address(lendingPool), type(uint256).max);
        lendingPool.redeem(3, type(uint256).max, treasuryAddress, false);
        console.log("--- Treasury Receive USDC: %e", USDC.balanceOf(treasuryAddress));
        debugReserve(3);

        vm.startPrank(user);
        eToken3.approve(address(lendingPool), type(uint256).max);
        lendingPool.redeem(3, type(uint256).max, address(0x123), false);

        console.log("--- User Receive USDC: %e", USDC.balanceOf(address(0x123)));
        debugReserve(3);
    }

    function debugReserve(uint256 reserveId) public view {
        console.log("----Reserve Status [%d]----", reserveId);
        // console.log("%s Underlying Token Address", lendingPool.getUnderlyingTokenAddress(reserveId));
        // console.log("%s eToken Address", lendingPool.getETokenAddress(reserveId));
        // console.log("%s Staking Address", lendingPool.getStakingAddress(reserveId));
        console.log("%e Total Liquidity", lendingPool.totalLiquidityOfReserve(reserveId));
        console.log("%e Total Borrows", lendingPool.totalBorrowsOfReserve(reserveId));
        console.log("%e Exchange Rate", lendingPool.exchangeRateOfReserve(reserveId));
        console.log("%e Utilization Rate", lendingPool.utilizationRateOfReserve(reserveId));
        console.log("%e Borrowing Rate", lendingPool.borrowingRateOfReserve(reserveId));
        // Additional reserve properties (like fee rate, booleans, update timestamp, borrowing index)
        // would need new getter functions in LendingPool.
        console.log("%e BorrowingIndex", lendingPool.latestBorrowingIndex(reserveId));
    }
}

```

## Recommendation

Fancy Math problem.
The solution solved by chatGPT seem accurate when plugged in and rerun test. Unsure if it would work correctly.

```solidity
function _mintToTreasury(
        DataTypes.ReserveData storage reserve,
        uint256 previousDebt,
        uint256 currentDebt,
        address treasury
    ) internal {
        uint256 feeRate = reserve.reserveFeeRate;// 15.00%

        if (feeRate == 0) {
            return;
        }

        //debt accrued is the current debt minus the debt at the last update
        uint256 totalDebtAccrued = currentDebt.sub(previousDebt);//e6 token rounded down too much
        uint256 reserveValueAccrued = totalDebtAccrued.mul(feeRate).div(Constants.PERCENT_100);// =*1500 / 10000
        // reserve value to eTokens
        // uint256 exchangeRate = reserveToETokenExchangeRate(reserve);//this rate < 1 . also depend on asset/token decimals
        // uint256 feeInEToken = reserveValueAccrued.mul(exchangeRate).div(Precision.FACTOR1E18);
        if(reserveValueAccrued == 0) return;
        (uint totalAsset,) = totalLiquidityAndBorrows(reserve);
        uint256 feeInEToken = reserveValueAccrued     // F
                 * IExtraInterestBearingToken(reserve.eTokenAddress).totalSupply()         // S
                 / (totalAsset - reserveValueAccrued); // A - F


        if (feeInEToken != 0) {
            IExtraInterestBearingToken(reserve.eTokenAddress).mintToTreasury(treasury, feeInEToken);
        }//@audit H03 minting fee seem like fee take from user seem like not correct.
    }
```
