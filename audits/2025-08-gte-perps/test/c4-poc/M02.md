# `SimpleBondingCurve` Rounding error causes underflow when selling all token

## Links

<https://github.com/code-423n4/2025-08-gte-perps/blob/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/BondingCurves/SimpleBondingCurve.sol#L132-L134>

## Finding description and impact

> Scenario: On a new deployed meme token
> User buys some token from launchpad several times
> User sells all their token holding
> Unexpectedly, the transaction reverts due to underflow in `SimpleBondingCurve` contract

**Impact:** unexpected behaviour. User cannot fully exit during bonding phase.

The root cause: this `SimpleBondingCurve` invariant `reserves[token].quoteReserve < VIRTUAL_QUOTE` is possible.

---
In `LaunchPad.sol`, `_emitSwapEvent()` function calls `curve.quoteBoughtByCurve()` to get current token price on every buy/sell order. [Ref](https://github.com/code-423n4/2025-08-gte-perps/blob/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/Launchpad.sol#L605-L606)

When user make last sell order to exit, the quote reserve should return to baseline virtual reserve (`reserves[token].quoteReserve == VIRTUAL_QUOTE_RESERVE`) but due to rounding error, it is slightly below the virtual reserve.

Causing underflow in `SimpleBondingCurve.quoteBoughtByCurve()` view function.

Preventing user from fully exiting during bonding phase.

---
Rounding come from `_getQuoteAmount()` function and only have tiny precision loss of wei unit. This is unavoidable.

```solidity
    function _getBaseAmount(uint256 quoteAmount, uint256 quoteReserve, uint256 baseReserve, bool isBuy)
        internal
        pure
        returns (uint256 baseAmount)
    {
        uint256 quoteReserveAfter = isBuy ? quoteReserve + quoteAmount : quoteReserve - quoteAmount;

        return (quoteAmount * baseReserve) / quoteReserveAfter;
    }

    function _getQuoteAmount(uint256 baseAmount, uint256 quoteReserve, uint256 baseReserve, bool isBuy)
        internal
        pure
        returns (uint256 quoteAmount)
    {
        uint256 baseReserveAfter = isBuy ? baseReserve - baseAmount : baseReserve + baseAmount;

        return (quoteReserve * baseAmount) / baseReserveAfter;
        // if(isBuy){
        //     uint256 baseReserveAfter = baseReserve - baseAmount;
        //     return Math.mulDiv(quoteReserve, baseAmount, baseReserveAfter, Math.Rounding.Ceil);
        // }
        // else{
        //     uint256 baseReserveAfter = baseReserve + baseAmount;
        //     return Math.mulDiv(quoteReserve, baseAmount, baseReserveAfter, Math.Rounding.Floor);
        // }
    }
```

## Recommended mitigation steps

Capping minimum quote reserve to virtual reserve should be a reasonable mitigation.

```solidity
    function sell(address token, uint256 baseAmount) external onlyLaunchpad returns (uint256 quoteAmount) {
        Reserves storage r = reserves[token];
        // quote reserve * baseAmount / (baseReserve + baseAmount)
        quoteAmount = _getQuoteAmount(baseAmount, r.quoteReserve, r.baseReserve, false);
        r.quoteReserve -= quoteAmount;//@audit M there is a case where r.quoteReserve < VIRTUAL_QUOTE. leads to underflow when emit events
        r.baseReserve += baseAmount;
        //@fix add this minimum
        if (r.quoteReserve < VIRTUAL_QUOTE_RESERVE) {
            r.quoteReserve = VIRTUAL_QUOTE_RESERVE;
        }
    }
```

## POC

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./LaunchpadTestBase.sol";
import {SafeTransferLib} from "@solady/utils/SafeTransferLib.sol";
import "contracts/launchpad/libraries/RewardsTracker.sol";

contract PoCLaunchpad is LaunchpadTestBase {
    using SafeTransferLib for address;


    function test_debug_submissionValidity() external {
        fundAndApproveUser(dev, 100 ether);
        fundAndApproveUser(user, 100 ether);

        buyLaunchToken(token, dev, 150_000_000e18);
        buyLaunchToken(token, dev, 120_000_000e18);
        buyLaunchToken(token, dev, 130_000_000e18);

        //expect revert here
        console.log("--next call should not be revert--");
        vm.expectRevert(address(launchpad.currentBondingCurve()));
        sellLaunchToken(token, dev, 400_000_000e18);
        //sell 400M base token to ~6.66666666e18 quote token
        //quote reserve is ~16.666666665e18
        //this push the quote reserve below 10e18
        //virtual reserve is 10e18
        //it then reverts underflow in SimpleBondingCurve.quoteBoughtByCurve()
    }


    function fundAndApproveUser(address _user, uint256 amount) internal {
        quoteToken.mint(_user, amount);
        vm.startPrank(_user);
        quoteToken.approve(address(launchpad), type(uint256).max);
        ERC20Harness(token).approve(address(launchpad), type(uint256).max);
        vm.stopPrank();
    }

    function buyLaunchToken(address _token, address fromUser, uint256 amountOutBase) internal {
        vm.startPrank(fromUser);
        launchpad.buy(
            ILaunchpad.BuyData({
                account: fromUser,
                token: _token,
                recipient: fromUser,
                amountOutBase: amountOutBase,
                maxAmountInQuote: type(uint256).max
            })
        );
        vm.stopPrank();
    }

    function sellLaunchToken(address _token, address fromUser, uint256 amountInBase) internal {
        vm.startPrank(fromUser);
        launchpad.sell(fromUser, _token, fromUser, amountInBase, 0);
        vm.stopPrank();
    }
}


```
