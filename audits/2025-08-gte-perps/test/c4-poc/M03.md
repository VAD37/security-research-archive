# User try to sell all token in bonding phase will fail

## Links

<https://github.com/code-423n4/2025-08-gte-perps/blob/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/LaunchToken.sol#L147>

## Finding description and impact

>Consider the scenario where a user buys meme tokens from the launchpad and then immediately tries to sell all of them to recover their initial funds.
The launchpad `sell` call will unexpectedly revert. The user can sell 99% of their holdings successfully, but not the full 100%.

[The root cause is in `LaunchToken.sol`.](https://github.com/code-423n4/2025-08-gte-perps/blob/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/LaunchToken.sol#L147)

```solidity
if (totalFeeShare == 0 && !unlocked) _endRewards();
```

When all users sell their last tokens, `LaunchToken` attempts to end rewards during the bonding phase.
Since no token pair exists in the bonding phase, the `_endRewards()` call targets a non-existent contract and reverts.

**Impact:** unexpected behaviour. User cannot fully exit during bonding phase.

*(This report only focus on impact of what happen to user when rewards ended in bonding phase)*

### Details

When users sell every token shares from launchpad. It trigger `_decreaseFeeShares()` on token transfer
And if it is bonding phase it then trigger `_endRewards()` function.

```solidity
    function _decreaseFeeShares(address account, uint256 amount) internal {
        uint256 share = bondingShare[account];
        if (share == 0 || account == address(0)) return;

        amount = amount > share ? share : amount;

        emit FeeShareDecreased(account, amount, _incEventNonce());

        unchecked {
            totalFeeShare -= amount;
            bondingShare[account] -= amount;
        }
        //@audit H end rewards never called also cause permanent lock token in GTEpair
        if (totalFeeShare == 0 && !unlocked) _endRewards();//@audit M there is an issue where ending rewards during bonding phase? when there is no pair token launched yet.
        ILaunchpad(launchpad).decreaseStake(account, uint96(amount));//distributor.decreaseStake
    }
```

Hooping through the code. `_endRewards()` try to call reach its token pair `GTELaunchpadV2Pair` to set swap fee to zero

```solidity
//LaunchToken.sol
    function _endRewards() internal {
        ILaunchpad(launchpad).endRewards();//@call Distributor.endRewards(LaunchToken/QuoteToken)

        emit FeeShareConcluded(block.timestamp, _incEventNonce());
    }
//LaunchPad.sol
    function endRewards() external onlyLaunchAsset {
        address quote = _launches[msg.sender].quote;
        // @todo stick with one pair interface
        IGTELaunchpadV2Pair pair = IGTELaunchpadV2Pair(address(pairFor(address(uniV2Factory), msg.sender, quote)));

        distributor.endRewards(pair);
    }
//Distributor.sol
    function endRewards(IGTELaunchpadV2Pair pair) external onlyLaunchpad {
        pair.endRewardsAccrual();
    }
//GTELaunchpadV2Pair.sol
    function endRewardsAccrual() external {
        if (msg.sender != launchpadFeeDistributor) revert("GTEUniV2: FORBIDDEN");

        // There are no more shares, so prevent distribution and accrual of any remaining rewards
        delete accruedLaunchpadFee0;
        delete accruedLaunchpadFee1;
        delete rewardsPoolActive;

        _update(
            IERC20(token0).balanceOf(address(this)),
            IERC20(token1).balanceOf(address(this)),
            reserve0,
            reserve1,
            uint112(0),
            uint112(0)
        );

        emit RewardsPoolDeactivated();
    }

```

The underlying issue is this pair `GTELaunchpadV2Pair` will never be created in bonding phase.

New token pair only created after 800M Launch Token is sold and unlocked.
Then it graduate token and create new token pair.
<https://github.com/code-423n4/2025-08-gte-perps/blob/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/Launchpad.sol#L301-L304>

`_endRewards()` call will always revert because it try to function on non-contract address.

## Recommended mitigation steps

Flip the boolean `unlocked` check.

```solidity
if (totalFeeShare == 0 && unlocked) _endRewards();
```

## POC

Because `LaunchpadTestBase` missing full integration with uniswap factory and codehash,
`LaunchPad.pairFor()` never return correct pair address.
So `LaunchPad.endRewards()` might call wrong address anyway.

This POC only show proof that `Distributor` trying to call "actual" not-deployed pair and fail with same scenario explained above.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./LaunchpadTestBase.sol";
import {SafeTransferLib} from "@solady/utils/SafeTransferLib.sol";
import "contracts/launchpad/libraries/RewardsTracker.sol";
import {UniswapV2Library, IUniswapV2Pair} from "@gte-univ2-periphery/UniswapV2Library.sol";
import {IUniswapV2Factory} from "@gte-univ2-core/interfaces/IUniswapV2Factory.sol";
import {GTELaunchpadV2PairFactory} from "contracts/launchpad/uniswap/GTELaunchpadV2PairFactory.sol";
import {GTELaunchpadV2Pair} from "contracts/launchpad/uniswap/GTELaunchpadV2Pair.sol";
import {IERC20} from "@openzeppelin/token/ERC20/IERC20.sol";
import {Distributor, IGTELaunchpadV2Pair} from "contracts/launchpad/Distributor.sol";

contract PoCLaunchpad is LaunchpadTestBase {
    using SafeTransferLib for address;

    GTELaunchpadV2PairFactory v2Factory;
    
    ///@notice Proof that LaunchPad create a pair with address 0x81018a3cBe285dB853B163CfE342049fDdb3BF1d after graduate
    function test_debug_submissionValidity_0() external {
        fundAndApproveUser(dev, 100 ether);
        buyLaunchToken(token, dev, BONDING_SUPPLY);
        // graduate token we get pair token from event
        // 0x81018a3cBe285dB853B163CfE342049fDdb3BF1d
        // emit PairCreated(token0: QuoteToken: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], token1: LaunchToken: [0xB377b41322D1cd0c2cd3E22C02DA7Ee1Dab1f690], pair: 0x81018a3cBe285dB853B163CfE342049fDdb3BF1d, : 1)
        address pair_create2_address = 0x81018a3cBe285dB853B163CfE342049fDdb3BF1d;
        vm.assertNotEq(pair_create2_address.code.length, 0, "pair contract should be created from uniswap factory");
        ///@ pair exist and functional and factory same as LaunchPad factory
        vm.assertEq(
            IUniswapV2Pair(pair_create2_address).factory(),
            uniV2Router.factory(),
            "pair factory should be uniswap factory"
        );
    }

    ///@notice show token buy/sell reverts at endRewards() in Distributor.sol
    //POC Steps:
    // 1. First User (developer) buys launch token
    // 2. User sells all launch token to recover their original investment
    // 3. Sell reverts at endRewards() in Distributor.sol. debug log show it trying to call empty address
    function test_debug_submissionValidity_1() external {
        fundAndApproveUser(dev, 100 ether);

        buyLaunchToken(token, dev, BONDING_SUPPLY / 2);
        // graduate token we get pair token from test_0
        address pair_create2_address = 0x81018a3cBe285dB853B163CfE342049fDdb3BF1d;
        vm.assertEq(pair_create2_address.code.length, 0, "pair contract should have no code yet");

        //@it just revert here
        //@revert calling pair contract with no code.

        // This test just demonstrate that distributor trying to call endrewards on empty EOA that not created yet
        // vm.expectRevert(distributor, "Distributor.endRewards(pair) call failed");
        sellLaunchToken(token, dev, BONDING_SUPPLY / 2);
    }

    function fundAndApproveUser(address _user, uint256 amount) internal {
        vm.startPrank(_user);
        quoteToken.mint(_user, amount);
        quoteToken.approve(address(launchpad), type(uint256).max);
        ERC20Harness(token).approve(address(launchpad), type(uint256).max);
        quoteToken.approve(address(uniV2Router), type(uint256).max);
        ERC20Harness(token).approve(address(uniV2Router), type(uint256).max);
        vm.stopPrank();
    }

    function buyLaunchToken(address _token, address fromUser, uint256 amountOutBase) internal {
        vm.startPrank(fromUser);
        launchpad.buy(
            ILaunchpad.BuyData({
                account: fromUser,
                token: _token,
                recipient: fromUser,
                amountOutBase: amountOutBase,
                maxAmountInQuote: type(uint256).max
            })
        );
        vm.stopPrank();
    }

    function sellLaunchToken(address _token, address fromUser, uint256 amountInBase) internal {
        vm.startPrank(fromUser);
        launchpad.sell(fromUser, _token, fromUser, amountInBase, 0);
        vm.stopPrank();
    }
}

```
