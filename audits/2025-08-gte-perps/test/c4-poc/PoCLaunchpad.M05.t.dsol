// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./LaunchpadTestBase.sol";
import {SafeTransferLib} from "@solady/utils/SafeTransferLib.sol";
import "contracts/launchpad/libraries/RewardsTracker.sol";
import {UniswapV2Library, IUniswapV2Pair} from "@gte-univ2-periphery/UniswapV2Library.sol";
import {IUniswapV2Factory} from "@gte-univ2-core/interfaces/IUniswapV2Factory.sol";
import {GTELaunchpadV2PairFactory} from "contracts/launchpad/uniswap/GTELaunchpadV2PairFactory.sol";
import {GTELaunchpadV2Pair} from "contracts/launchpad/uniswap/GTELaunchpadV2Pair.sol";
import {IERC20} from "@openzeppelin/token/ERC20/IERC20.sol";
import {Distributor, IGTELaunchpadV2Pair} from "contracts/launchpad/Distributor.sol";

contract PoCLaunchpad is LaunchpadTestBase {
    using SafeTransferLib for address;

    function test_debug_submissionValidity() external {
        fundAndApproveUser(dev, 100 ether);
        fundAndApproveUser(user, 100 ether);
        vm.assertEq(BONDING_SUPPLY, 800_000_000e18);
        buyLaunchToken(token, dev, 700_000_000e18); // buy 700M token
        //user aquires 100M token to graduate token
        buyLaunchToken(token, user, 100_000_000e18); // buy 100M token
        //check token graduation
        ILaunchpad.LaunchData memory launchdata = launchpad.launches(token);
        vm.assertFalse(launchdata.active, "graduated so disable launch mode");
        vm.assertTrue(LaunchToken(token).unlocked(), "graduated so token unlocked");

        console.log("dev Shares: %e", getUserShare(token, dev));
        console.log("user Shares: %e", getUserShare(token, user));
        uint256 user_original_share = getUserShare(token, user);
        // User can only buy more token from uniswap pair
        //user buy 50M token from uniswap pool
        //@ because mock uniswap router does not have liquidity, so full integration test is not possible
        // just mocking user receive launch token from uniswap pool
        console.log("user buy 50M token from uniswap pool");
        vm.prank(address(uniV2Router));
        IERC20(token).transfer(user, 50_000_000e18);
        console.log("user Shares: %e", getUserShare(token, user));

        console.log("user sell 30M token to uniswap pool");
        vm.prank(address(uniV2Router));
        IERC20(token).transferFrom(user, address(uniV2Router), 30_000_000e18);
        //Mocking user selling 30M token to uniswap pool
        console.log("user Shares after sell: %e", getUserShare(token, user));
        console.log("user LaunchToken balance after sell: %e", IERC20(token).balanceOf(user));
        console.log("User lost %e shares", user_original_share - getUserShare(token, user));
    }

    function fundAndApproveUser(address _user, uint256 amount) internal {
        vm.startPrank(_user);
        quoteToken.mint(_user, amount);
        quoteToken.approve(address(launchpad), type(uint256).max);
        ERC20Harness(token).approve(address(launchpad), type(uint256).max);
        quoteToken.approve(address(uniV2Router), type(uint256).max);
        ERC20Harness(token).approve(address(uniV2Router), type(uint256).max);
        vm.stopPrank();
    }

    function buyLaunchToken(address _token, address fromUser, uint256 amountOutBase) internal {
        vm.startPrank(fromUser);
        launchpad.buy(
            ILaunchpad.BuyData({
                account: fromUser,
                token: _token,
                recipient: fromUser,
                amountOutBase: amountOutBase,
                maxAmountInQuote: type(uint256).max
            })
        );
        vm.stopPrank();
    }

    function sellLaunchToken(address _token, address fromUser, uint256 amountInBase) internal {
        vm.startPrank(fromUser);
        launchpad.sell(fromUser, _token, fromUser, amountInBase, 0);
        vm.stopPrank();
    }

    function getUserShare(address _token, address _user) internal view returns (uint256) {
        UserRewardData memory data = Distributor(distributor).getUserData(_token, _user);
        return data.shares;
    }
}
