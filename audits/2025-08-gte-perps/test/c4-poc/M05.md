# User should not lose shares when holding more tokens

## Links

<https://github.com/code-423n4/2025-08-gte-perps/blob/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/LaunchToken.sol#L134-L150>

## Finding description and impact

> Scenario: User buys 100M tokens from `Launchpad` and gain 100M shares in `Distributor` rewards
> Token graduates to unlocked phase
> User buy another 50M token from uniswap pair
> User sells 30M token
> User lost 30M token shares despite still holding 120M tokens more than their original 100M tokens

**Impact:** User lose reward income despite still holding on their original meme token investment.

Root cause: After unlocked, `LaunchToken` aggresively try to reduce user share without checking user token balance.

---
For token launch presale/bonding phase, user gain shares when they buy tokens from launchpad.
Token transfer from launchpad to user and during locked phase will trigger
`LaunchToken._beforeTokenTransfer` and `_increaseFeeShares` to increase user share.

```solidity
    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {
        if (!unlocked && from != launchpad && to != launchpad && to != gteRouter) {
            revert TransfersDisabledWhileBonding();
        }//if bonding phase and both from,to not belong to launchpad/router, disable transfer

        if (!unlocked) {
            if (from != launchpad && to != launchpad && to != gteRouter) revert TransfersDisabledWhileBonding();

            if (from == launchpad && to != launchpad) _increaseFeeShares(to, amount);
            else if (to != launchpad && to != gteRouter) revert TransfersDisabledWhileBonding();
        }
        if (from != launchpad) _decreaseFeeShares(from, amount);//unlocked then reduce fee
    }

    function _increaseFeeShares(address account, uint256 amount) internal {
        if (amount == 0 || account == address(0)) return;

        emit FeeShareIncreased(account, amount, _incEventNonce());

        unchecked {
            totalFeeShare += amount;
            bondingShare[account] += amount;
        }

        ILaunchpad(launchpad).increaseStake(account, uint96(amount));//distributor.increaseStake
    }
```

Later on, to detect user sell their tokens, `LaunchToken._beforeTokenTransfer` detect if calls is from user and in graduated phase (token unlocked) will call `_decreaseFeeShares` to reduce user share based on transfer away amount.

```solidity
    function _decreaseFeeShares(address account, uint256 amount) internal {
        if (amount == 0 || account == address(0)) return;

        uint256 share = bondingShare[account];
        if (share == 0) return;//no share to reduce

        if (amount > share) amount = share;//cannot reduce more than share

        emit FeeShareDecreased(account, amount, _incEventNonce());

        unchecked {
            totalFeeShare -= amount;
            bondingShare[account] -= amount;
        }

        ILaunchpad(launchpad).decreaseStake(account, uint96(amount));//distributor.decreaseStake
    }
```

Because there is no check on user token balance, if user gain balance from either buying or receive from other user, their share still be reduced when they transfer away any amount of token.

## Recommended mitigation steps

Include balance check to make it more fair for user hold.

```solidity
    function _decreaseFeeShares(address account, uint256 amount) internal {
        if (amount == 0 || account == address(0)) return;

        uint256 share = bondingShare[account];
        if (share == 0) return;//no share to reduce

        if (amount > share) amount = share;//cannot reduce more than share

        uint256 bal = balanceOf(account);          // pre-transfer balance
        uint256 newBal = bal > amount ? bal - amount : 0;  // post-transfer balance (or 0 if over-debit path)

        // If the remaining balance still covers the share, do nothing
        if (newBal >= share) return;

        uint256 delta = share - newBal;            // how much share to drop

        unchecked {
            bondingShare[account] = newBal;        // clamp to new balance
            totalFeeShare -= delta;
        }

        emit FeeShareDecreased(account, delta, _incEventNonce());

        ILaunchpad(launchpad).decreaseStake(account, uint96(delta));
    }
```

## POC

```solidity

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./LaunchpadTestBase.sol";
import {SafeTransferLib} from "@solady/utils/SafeTransferLib.sol";
import "contracts/launchpad/libraries/RewardsTracker.sol";
import {UniswapV2Library, IUniswapV2Pair} from "@gte-univ2-periphery/UniswapV2Library.sol";
import {IUniswapV2Factory} from "@gte-univ2-core/interfaces/IUniswapV2Factory.sol";
import {GTELaunchpadV2PairFactory} from "contracts/launchpad/uniswap/GTELaunchpadV2PairFactory.sol";
import {GTELaunchpadV2Pair} from "contracts/launchpad/uniswap/GTELaunchpadV2Pair.sol";
import {IERC20} from "@openzeppelin/token/ERC20/IERC20.sol";
import {Distributor, IGTELaunchpadV2Pair} from "contracts/launchpad/Distributor.sol";

contract PoCLaunchpad is LaunchpadTestBase {
    using SafeTransferLib for address;

    function test_debug_submissionValidity() external {
        fundAndApproveUser(dev, 100 ether);
        fundAndApproveUser(user, 100 ether);
        vm.assertEq(BONDING_SUPPLY, 800_000_000e18);
        buyLaunchToken(token, dev, 700_000_000e18); // buy 700M token
        //user aquires 100M token to graduate token
        buyLaunchToken(token, user, 100_000_000e18); // buy 100M token
        //check token graduation
        ILaunchpad.LaunchData memory launchdata = launchpad.launches(token);
        vm.assertFalse(launchdata.active, "graduated so disable launch mode");
        vm.assertTrue(LaunchToken(token).unlocked(), "graduated so token unlocked");

        console.log("dev Shares: %e", getUserShare(token, dev));
        console.log("user Shares: %e", getUserShare(token, user));
        uint256 user_original_share = getUserShare(token, user);
        // User can only buy more token from uniswap pair
        //user buy 50M token from uniswap pool
        //@ because mock uniswap router does not have liquidity, so full integration test is not possible
        // just mocking user receive launch token from uniswap pool
        console.log("user buy 50M token from uniswap pool");
        vm.prank(address(uniV2Router));
        IERC20(token).transfer(user, 50_000_000e18);
        console.log("user Shares: %e", getUserShare(token, user));

        console.log("user sell 30M token to uniswap pool");
        vm.prank(address(uniV2Router));
        IERC20(token).transferFrom(user, address(uniV2Router), 30_000_000e18);
        //Mocking user selling 30M token to uniswap pool
        console.log("user Shares after sell: %e", getUserShare(token, user));
        console.log("user LaunchToken balance after sell: %e", IERC20(token).balanceOf(user));
        console.log("User lost %e shares", user_original_share - getUserShare(token, user));
    }

    function fundAndApproveUser(address _user, uint256 amount) internal {
        vm.startPrank(_user);
        quoteToken.mint(_user, amount);
        quoteToken.approve(address(launchpad), type(uint256).max);
        ERC20Harness(token).approve(address(launchpad), type(uint256).max);
        quoteToken.approve(address(uniV2Router), type(uint256).max);
        ERC20Harness(token).approve(address(uniV2Router), type(uint256).max);
        vm.stopPrank();
    }

    function buyLaunchToken(address _token, address fromUser, uint256 amountOutBase) internal {
        vm.startPrank(fromUser);
        launchpad.buy(
            ILaunchpad.BuyData({
                account: fromUser,
                token: _token,
                recipient: fromUser,
                amountOutBase: amountOutBase,
                maxAmountInQuote: type(uint256).max
            })
        );
        vm.stopPrank();
    }

    function sellLaunchToken(address _token, address fromUser, uint256 amountInBase) internal {
        vm.startPrank(fromUser);
        launchpad.sell(fromUser, _token, fromUser, amountInBase, 0);
        vm.stopPrank();
    }

    function getUserShare(address _token, address _user) internal view returns (uint256) {
        UserRewardData memory data = Distributor(distributor).getUserData(_token, _user);
        return data.shares;
    }
}

```
