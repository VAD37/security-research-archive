
# User selling all tokens in bonding phase will fail

## Links

[https://github.com/code-423n4/2025-08-gte-perps/blob/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/LaunchToken.sol#L147](https://github.com/code-423n4/2025-08-gte-perps/blob/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/LaunchToken.sol#L147)

## Finding description and impact

> Consider the scenario where a user buys meme tokens from the launchpad and then immediately tries to sell all of them to recover their initial funds.
> The launchpad `sell` call will unexpectedly revert. The user can sell 99% of their holdings successfully, but not the full 100%.

[The underlying issue is in `LaunchToken.sol`.](https://github.com/code-423n4/2025-08-gte-perps/blob/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/LaunchToken.sol#L147)

```solidity
if (totalFeeShare == 0 && !unlocked) _endRewards();
```

When all users sell their last tokens, `LaunchToken` attempts to end rewards during the *bonding phase*.
Since no token pair exists in the bonding phase, the `_endRewards()` call targets a non-existent contract and reverts.

**Impact:** Users cannot fully exit during the bonding phase, resulting in unexpected behavior.

*(This report only focuses on the impact of what happens to users when rewards end in the bonding phase.)*

---

### Details

When users sell all their token shares from the launchpad, `_decreaseFeeShares()` is triggered on token transfer.
If this occurs during the bonding phase, `_endRewards()` is also triggered.

```solidity
function _decreaseFeeShares(address account, uint256 amount) internal {
    uint256 share = bondingShare[account];
    if (share == 0 || account == address(0)) return;

    amount = amount > share ? share : amount;

    emit FeeShareDecreased(account, amount, _incEventNonce());

    unchecked {
        totalFeeShare -= amount;
        bondingShare[account] -= amount;
    }

    if (totalFeeShare == 0 && !unlocked) _endRewards();
    ILaunchpad(launchpad).decreaseStake(account, uint96(amount));
}
```

---
Tracing through the code:

* `_endRewards()` calls into the launchpad to end rewards.
* This cascades down to `Distributor.endRewards()`, which ultimately tries to call `pair.endRewardsAccrual()`.
* However, in bonding phase, the pair `GTELaunchpadV2Pair` has not yet been created.

Result: `_endRewards()` always reverts because it interacts with an address that has no deployed contract.

```solidity
//LaunchToken.sol
    function _endRewards() internal {
        ILaunchpad(launchpad).endRewards();//@call Distributor.endRewards(LaunchToken/QuoteToken)

        emit FeeShareConcluded(block.timestamp, _incEventNonce());
    }
//LaunchPad.sol
    function endRewards() external onlyLaunchAsset {
        address quote = _launches[msg.sender].quote;
        // @todo stick with one pair interface
        IGTELaunchpadV2Pair pair = IGTELaunchpadV2Pair(address(pairFor(address(uniV2Factory), msg.sender, quote)));

        distributor.endRewards(pair);
    }
//Distributor.sol
    function endRewards(IGTELaunchpadV2Pair pair) external onlyLaunchpad {
        pair.endRewardsAccrual();
    }
//GTELaunchpadV2Pair.sol
    function endRewardsAccrual() external {
        if (msg.sender != launchpadFeeDistributor) revert("GTEUniV2: FORBIDDEN");

        // There are no more shares, so prevent distribution and accrual of any remaining rewards
        delete accruedLaunchpadFee0;
        delete accruedLaunchpadFee1;
        delete rewardsPoolActive;

        _update(
            IERC20(token0).balanceOf(address(this)),
            IERC20(token1).balanceOf(address(this)),
            reserve0,
            reserve1,
            uint112(0),
            uint112(0)
        );

        emit RewardsPoolDeactivated();
    }

```

---

Token pairs are only created after 800M Launch Tokens are sold and unlocked. At that point, the system graduates the token and creates a new pair.
[https://github.com/code-423n4/2025-08-gte-perps/blob/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/Launchpad.sol#L301-L304](https://github.com/code-423n4/2025-08-gte-perps/blob/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/Launchpad.sol#L301-L304)

Therefore, `_endRewards()` should be called only after graduation.

## Recommended mitigation steps

Flip the `unlocked` condition:

```solidity
if (totalFeeShare == 0 && unlocked) _endRewards();
```

## Proof of Concept (PoC)

Because `LaunchpadTestBase` is missing full integration with the Uniswap factory and codehash,
`LaunchPad.pairFor()` never returns the correct pair address.
As a result, `LaunchPad.endRewards()` may still call the wrong address.

This PoC shows that `Distributor` attempts to call a non-deployed pair contract, failing under the exact scenario described.


Run with `forge test -vvv --mt debug`
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./LaunchpadTestBase.sol";
import {SafeTransferLib} from "@solady/utils/SafeTransferLib.sol";
import "contracts/launchpad/libraries/RewardsTracker.sol";
import {UniswapV2Library, IUniswapV2Pair} from "@gte-univ2-periphery/UniswapV2Library.sol";
import {IUniswapV2Factory} from "@gte-univ2-core/interfaces/IUniswapV2Factory.sol";
import {GTELaunchpadV2PairFactory} from "contracts/launchpad/uniswap/GTELaunchpadV2PairFactory.sol";
import {GTELaunchpadV2Pair} from "contracts/launchpad/uniswap/GTELaunchpadV2Pair.sol";
import {IERC20} from "@openzeppelin/token/ERC20/IERC20.sol";
import {Distributor, IGTELaunchpadV2Pair} from "contracts/launchpad/Distributor.sol";

contract PoCLaunchpad is LaunchpadTestBase {
    using SafeTransferLib for address;

    GTELaunchpadV2PairFactory v2Factory;
    
    ///@notice Proof that LaunchPad create a pair with address 0x81018a3cBe285dB853B163CfE342049fDdb3BF1d after graduate
    function test_debug_submissionValidity_0() external {
        fundAndApproveUser(dev, 100 ether);
        buyLaunchToken(token, dev, BONDING_SUPPLY);
        // graduate token we get pair token from event
        // 0x81018a3cBe285dB853B163CfE342049fDdb3BF1d
        // emit PairCreated(token0: QuoteToken: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f], token1: LaunchToken: [0xB377b41322D1cd0c2cd3E22C02DA7Ee1Dab1f690], pair: 0x81018a3cBe285dB853B163CfE342049fDdb3BF1d, : 1)
        address pair_create2_address = 0x81018a3cBe285dB853B163CfE342049fDdb3BF1d;
        vm.assertNotEq(pair_create2_address.code.length, 0, "pair contract should be created from uniswap factory");
        ///@ pair exist and functional and factory same as LaunchPad factory
        vm.assertEq(
            IUniswapV2Pair(pair_create2_address).factory(),
            uniV2Router.factory(),
            "pair factory should be uniswap factory"
        );
    }

    ///@notice show token buy/sell reverts at endRewards() in Distributor.sol
    //POC Steps:
    // 1. First User (developer) buys launch token
    // 2. User sells all launch token to recover their original investment
    // 3. Sell reverts at endRewards() in Distributor.sol. debug log show it trying to call empty address
    function test_debug_submissionValidity_1() external {
        fundAndApproveUser(dev, 100 ether);

        buyLaunchToken(token, dev, BONDING_SUPPLY / 2);
        // graduate token we get pair token from test_0
        address pair_create2_address = 0x81018a3cBe285dB853B163CfE342049fDdb3BF1d;
        vm.assertEq(pair_create2_address.code.length, 0, "pair contract should have no code yet");

        //@it just revert here
        //@revert calling pair contract with no code.

        // This test just demonstrate that distributor trying to call endrewards on empty EOA that not created yet
        // vm.expectRevert(distributor, "Distributor.endRewards(pair) call failed");
        sellLaunchToken(token, dev, BONDING_SUPPLY / 2);
    }

    function fundAndApproveUser(address _user, uint256 amount) internal {
        vm.startPrank(_user);
        quoteToken.mint(_user, amount);
        quoteToken.approve(address(launchpad), type(uint256).max);
        ERC20Harness(token).approve(address(launchpad), type(uint256).max);
        quoteToken.approve(address(uniV2Router), type(uint256).max);
        ERC20Harness(token).approve(address(uniV2Router), type(uint256).max);
        vm.stopPrank();
    }

    function buyLaunchToken(address _token, address fromUser, uint256 amountOutBase) internal {
        vm.startPrank(fromUser);
        launchpad.buy(
            ILaunchpad.BuyData({
                account: fromUser,
                token: _token,
                recipient: fromUser,
                amountOutBase: amountOutBase,
                maxAmountInQuote: type(uint256).max
            })
        );
        vm.stopPrank();
    }

    function sellLaunchToken(address _token, address fromUser, uint256 amountInBase) internal {
        vm.startPrank(fromUser);
        launchpad.sell(fromUser, _token, fromUser, amountInBase, 0);
        vm.stopPrank();
    }
}
```