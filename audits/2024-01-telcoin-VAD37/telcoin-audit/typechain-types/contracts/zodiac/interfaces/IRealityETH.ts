/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../../common";

export interface IRealityETHInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "arbitrator_question_fees"
      | "askQuestion"
      | "askQuestionWithMinBond"
      | "assignWinnerAndSubmitAnswerByArbitrator"
      | "balanceOf"
      | "cancelArbitration"
      | "claimMultipleAndWithdrawBalance"
      | "claimWinnings"
      | "commitments"
      | "createTemplate"
      | "createTemplateAndAskQuestion"
      | "fundAnswerBounty"
      | "getArbitrator"
      | "getBestAnswer"
      | "getBond"
      | "getBounty"
      | "getContentHash"
      | "getFinalAnswer"
      | "getFinalAnswerIfMatches"
      | "getFinalizeTS"
      | "getHistoryHash"
      | "getMinBond"
      | "getOpeningTS"
      | "getTimeout"
      | "isFinalized"
      | "isPendingArbitration"
      | "isSettledTooSoon"
      | "notifyOfArbitrationRequest"
      | "question_claims"
      | "questions"
      | "reopenQuestion"
      | "reopened_questions"
      | "reopener_questions"
      | "resultFor"
      | "resultForOnceSettled"
      | "setQuestionFee"
      | "submitAnswer"
      | "submitAnswerByArbitrator"
      | "submitAnswerCommitment"
      | "submitAnswerFor"
      | "submitAnswerReveal"
      | "template_hashes"
      | "templates"
      | "withdraw"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "LogAnswerReveal"
      | "LogCancelArbitration"
      | "LogClaim"
      | "LogFinalize"
      | "LogFundAnswerBounty"
      | "LogMinimumBond"
      | "LogNewAnswer"
      | "LogNewQuestion"
      | "LogNewTemplate"
      | "LogNotifyOfArbitrationRequest"
      | "LogReopenQuestion"
      | "LogSetQuestionFee"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "arbitrator_question_fees",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "askQuestion",
    values: [
      BigNumberish,
      string,
      AddressLike,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "askQuestionWithMinBond",
    values: [
      BigNumberish,
      string,
      AddressLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "assignWinnerAndSubmitAnswerByArbitrator",
    values: [
      BytesLike,
      BytesLike,
      AddressLike,
      BytesLike,
      BytesLike,
      AddressLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOf",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelArbitration",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "claimMultipleAndWithdrawBalance",
    values: [
      BytesLike[],
      BigNumberish[],
      BytesLike[],
      AddressLike[],
      BigNumberish[],
      BytesLike[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "claimWinnings",
    values: [BytesLike, BytesLike[], AddressLike[], BigNumberish[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "commitments",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "createTemplate",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "createTemplateAndAskQuestion",
    values: [
      string,
      string,
      AddressLike,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fundAnswerBounty",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getArbitrator",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getBestAnswer",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "getBond", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "getBounty",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getContentHash",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getFinalAnswer",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getFinalAnswerIfMatches",
    values: [BytesLike, BytesLike, AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getFinalizeTS",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getHistoryHash",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getMinBond",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getOpeningTS",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTimeout",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isFinalized",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isPendingArbitration",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isSettledTooSoon",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "notifyOfArbitrationRequest",
    values: [BytesLike, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "question_claims",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "questions",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "reopenQuestion",
    values: [
      BigNumberish,
      string,
      AddressLike,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "reopened_questions",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "reopener_questions",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "resultFor",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "resultForOnceSettled",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setQuestionFee",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "submitAnswer",
    values: [BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "submitAnswerByArbitrator",
    values: [BytesLike, BytesLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "submitAnswerCommitment",
    values: [BytesLike, BytesLike, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "submitAnswerFor",
    values: [BytesLike, BytesLike, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "submitAnswerReveal",
    values: [BytesLike, BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "template_hashes",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "templates",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "withdraw", values?: undefined): string;

  decodeFunctionResult(
    functionFragment: "arbitrator_question_fees",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "askQuestion",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "askQuestionWithMinBond",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assignWinnerAndSubmitAnswerByArbitrator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "cancelArbitration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimMultipleAndWithdrawBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimWinnings",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "commitments",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createTemplate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createTemplateAndAskQuestion",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fundAnswerBounty",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getArbitrator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBestAnswer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getBond", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getBounty", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getContentHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFinalAnswer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFinalAnswerIfMatches",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFinalizeTS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getHistoryHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getMinBond", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getOpeningTS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getTimeout", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isFinalized",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isPendingArbitration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isSettledTooSoon",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "notifyOfArbitrationRequest",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "question_claims",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "questions", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "reopenQuestion",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reopened_questions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reopener_questions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "resultFor", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "resultForOnceSettled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setQuestionFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitAnswer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitAnswerByArbitrator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitAnswerCommitment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitAnswerFor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitAnswerReveal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "template_hashes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "templates", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
}

export namespace LogAnswerRevealEvent {
  export type InputTuple = [
    question_id: BytesLike,
    user: AddressLike,
    answer_hash: BytesLike,
    answer: BytesLike,
    nonce: BigNumberish,
    bond: BigNumberish
  ];
  export type OutputTuple = [
    question_id: string,
    user: string,
    answer_hash: string,
    answer: string,
    nonce: bigint,
    bond: bigint
  ];
  export interface OutputObject {
    question_id: string;
    user: string;
    answer_hash: string;
    answer: string;
    nonce: bigint;
    bond: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LogCancelArbitrationEvent {
  export type InputTuple = [question_id: BytesLike];
  export type OutputTuple = [question_id: string];
  export interface OutputObject {
    question_id: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LogClaimEvent {
  export type InputTuple = [
    question_id: BytesLike,
    user: AddressLike,
    amount: BigNumberish
  ];
  export type OutputTuple = [question_id: string, user: string, amount: bigint];
  export interface OutputObject {
    question_id: string;
    user: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LogFinalizeEvent {
  export type InputTuple = [question_id: BytesLike, answer: BytesLike];
  export type OutputTuple = [question_id: string, answer: string];
  export interface OutputObject {
    question_id: string;
    answer: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LogFundAnswerBountyEvent {
  export type InputTuple = [
    question_id: BytesLike,
    bounty_added: BigNumberish,
    bounty: BigNumberish,
    user: AddressLike
  ];
  export type OutputTuple = [
    question_id: string,
    bounty_added: bigint,
    bounty: bigint,
    user: string
  ];
  export interface OutputObject {
    question_id: string;
    bounty_added: bigint;
    bounty: bigint;
    user: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LogMinimumBondEvent {
  export type InputTuple = [question_id: BytesLike, min_bond: BigNumberish];
  export type OutputTuple = [question_id: string, min_bond: bigint];
  export interface OutputObject {
    question_id: string;
    min_bond: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LogNewAnswerEvent {
  export type InputTuple = [
    answer: BytesLike,
    question_id: BytesLike,
    history_hash: BytesLike,
    user: AddressLike,
    bond: BigNumberish,
    ts: BigNumberish,
    is_commitment: boolean
  ];
  export type OutputTuple = [
    answer: string,
    question_id: string,
    history_hash: string,
    user: string,
    bond: bigint,
    ts: bigint,
    is_commitment: boolean
  ];
  export interface OutputObject {
    answer: string;
    question_id: string;
    history_hash: string;
    user: string;
    bond: bigint;
    ts: bigint;
    is_commitment: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LogNewQuestionEvent {
  export type InputTuple = [
    question_id: BytesLike,
    user: AddressLike,
    template_id: BigNumberish,
    question: string,
    content_hash: BytesLike,
    arbitrator: AddressLike,
    timeout: BigNumberish,
    opening_ts: BigNumberish,
    nonce: BigNumberish,
    created: BigNumberish
  ];
  export type OutputTuple = [
    question_id: string,
    user: string,
    template_id: bigint,
    question: string,
    content_hash: string,
    arbitrator: string,
    timeout: bigint,
    opening_ts: bigint,
    nonce: bigint,
    created: bigint
  ];
  export interface OutputObject {
    question_id: string;
    user: string;
    template_id: bigint;
    question: string;
    content_hash: string;
    arbitrator: string;
    timeout: bigint;
    opening_ts: bigint;
    nonce: bigint;
    created: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LogNewTemplateEvent {
  export type InputTuple = [
    template_id: BigNumberish,
    user: AddressLike,
    question_text: string
  ];
  export type OutputTuple = [
    template_id: bigint,
    user: string,
    question_text: string
  ];
  export interface OutputObject {
    template_id: bigint;
    user: string;
    question_text: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LogNotifyOfArbitrationRequestEvent {
  export type InputTuple = [question_id: BytesLike, user: AddressLike];
  export type OutputTuple = [question_id: string, user: string];
  export interface OutputObject {
    question_id: string;
    user: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LogReopenQuestionEvent {
  export type InputTuple = [
    question_id: BytesLike,
    reopened_question_id: BytesLike
  ];
  export type OutputTuple = [question_id: string, reopened_question_id: string];
  export interface OutputObject {
    question_id: string;
    reopened_question_id: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace LogSetQuestionFeeEvent {
  export type InputTuple = [arbitrator: AddressLike, amount: BigNumberish];
  export type OutputTuple = [arbitrator: string, amount: bigint];
  export interface OutputObject {
    arbitrator: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface IRealityETH extends BaseContract {
  connect(runner?: ContractRunner | null): IRealityETH;
  waitForDeployment(): Promise<this>;

  interface: IRealityETHInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  arbitrator_question_fees: TypedContractMethod<
    [arg0: AddressLike],
    [bigint],
    "view"
  >;

  askQuestion: TypedContractMethod<
    [
      template_id: BigNumberish,
      question: string,
      arbitrator: AddressLike,
      timeout: BigNumberish,
      opening_ts: BigNumberish,
      nonce: BigNumberish
    ],
    [string],
    "payable"
  >;

  askQuestionWithMinBond: TypedContractMethod<
    [
      template_id: BigNumberish,
      question: string,
      arbitrator: AddressLike,
      timeout: BigNumberish,
      opening_ts: BigNumberish,
      nonce: BigNumberish,
      min_bond: BigNumberish
    ],
    [string],
    "payable"
  >;

  assignWinnerAndSubmitAnswerByArbitrator: TypedContractMethod<
    [
      question_id: BytesLike,
      answer: BytesLike,
      payee_if_wrong: AddressLike,
      last_history_hash: BytesLike,
      last_answer_or_commitment_id: BytesLike,
      last_answerer: AddressLike
    ],
    [void],
    "nonpayable"
  >;

  balanceOf: TypedContractMethod<[arg0: AddressLike], [bigint], "view">;

  cancelArbitration: TypedContractMethod<
    [question_id: BytesLike],
    [void],
    "nonpayable"
  >;

  claimMultipleAndWithdrawBalance: TypedContractMethod<
    [
      question_ids: BytesLike[],
      lengths: BigNumberish[],
      hist_hashes: BytesLike[],
      addrs: AddressLike[],
      bonds: BigNumberish[],
      answers: BytesLike[]
    ],
    [void],
    "nonpayable"
  >;

  claimWinnings: TypedContractMethod<
    [
      question_id: BytesLike,
      history_hashes: BytesLike[],
      addrs: AddressLike[],
      bonds: BigNumberish[],
      answers: BytesLike[]
    ],
    [void],
    "nonpayable"
  >;

  commitments: TypedContractMethod<
    [arg0: BytesLike],
    [
      [bigint, boolean, string] & {
        reveal_ts: bigint;
        is_revealed: boolean;
        revealed_answer: string;
      }
    ],
    "view"
  >;

  createTemplate: TypedContractMethod<
    [content: string],
    [bigint],
    "nonpayable"
  >;

  createTemplateAndAskQuestion: TypedContractMethod<
    [
      content: string,
      question: string,
      arbitrator: AddressLike,
      timeout: BigNumberish,
      opening_ts: BigNumberish,
      nonce: BigNumberish
    ],
    [string],
    "payable"
  >;

  fundAnswerBounty: TypedContractMethod<
    [question_id: BytesLike],
    [void],
    "payable"
  >;

  getArbitrator: TypedContractMethod<
    [question_id: BytesLike],
    [string],
    "view"
  >;

  getBestAnswer: TypedContractMethod<
    [question_id: BytesLike],
    [string],
    "view"
  >;

  getBond: TypedContractMethod<[question_id: BytesLike], [bigint], "view">;

  getBounty: TypedContractMethod<[question_id: BytesLike], [bigint], "view">;

  getContentHash: TypedContractMethod<
    [question_id: BytesLike],
    [string],
    "view"
  >;

  getFinalAnswer: TypedContractMethod<
    [question_id: BytesLike],
    [string],
    "view"
  >;

  getFinalAnswerIfMatches: TypedContractMethod<
    [
      question_id: BytesLike,
      content_hash: BytesLike,
      arbitrator: AddressLike,
      min_timeout: BigNumberish,
      min_bond: BigNumberish
    ],
    [string],
    "view"
  >;

  getFinalizeTS: TypedContractMethod<
    [question_id: BytesLike],
    [bigint],
    "view"
  >;

  getHistoryHash: TypedContractMethod<
    [question_id: BytesLike],
    [string],
    "view"
  >;

  getMinBond: TypedContractMethod<[question_id: BytesLike], [bigint], "view">;

  getOpeningTS: TypedContractMethod<[question_id: BytesLike], [bigint], "view">;

  getTimeout: TypedContractMethod<[question_id: BytesLike], [bigint], "view">;

  isFinalized: TypedContractMethod<[question_id: BytesLike], [boolean], "view">;

  isPendingArbitration: TypedContractMethod<
    [question_id: BytesLike],
    [boolean],
    "view"
  >;

  isSettledTooSoon: TypedContractMethod<
    [question_id: BytesLike],
    [boolean],
    "view"
  >;

  notifyOfArbitrationRequest: TypedContractMethod<
    [
      question_id: BytesLike,
      requester: AddressLike,
      max_previous: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  question_claims: TypedContractMethod<
    [arg0: BytesLike],
    [
      [string, bigint, bigint] & {
        payee: string;
        last_bond: bigint;
        queued_funds: bigint;
      }
    ],
    "view"
  >;

  questions: TypedContractMethod<
    [arg0: BytesLike],
    [
      [
        string,
        string,
        bigint,
        bigint,
        bigint,
        boolean,
        bigint,
        string,
        string,
        bigint,
        bigint
      ] & {
        content_hash: string;
        arbitrator: string;
        opening_ts: bigint;
        timeout: bigint;
        finalize_ts: bigint;
        is_pending_arbitration: boolean;
        bounty: bigint;
        best_answer: string;
        history_hash: string;
        bond: bigint;
        min_bond: bigint;
      }
    ],
    "view"
  >;

  reopenQuestion: TypedContractMethod<
    [
      template_id: BigNumberish,
      question: string,
      arbitrator: AddressLike,
      timeout: BigNumberish,
      opening_ts: BigNumberish,
      nonce: BigNumberish,
      min_bond: BigNumberish,
      reopens_question_id: BytesLike
    ],
    [string],
    "payable"
  >;

  reopened_questions: TypedContractMethod<[arg0: BytesLike], [string], "view">;

  reopener_questions: TypedContractMethod<[arg0: BytesLike], [boolean], "view">;

  resultFor: TypedContractMethod<[question_id: BytesLike], [string], "view">;

  resultForOnceSettled: TypedContractMethod<
    [question_id: BytesLike],
    [string],
    "view"
  >;

  setQuestionFee: TypedContractMethod<
    [fee: BigNumberish],
    [void],
    "nonpayable"
  >;

  submitAnswer: TypedContractMethod<
    [question_id: BytesLike, answer: BytesLike, max_previous: BigNumberish],
    [void],
    "payable"
  >;

  submitAnswerByArbitrator: TypedContractMethod<
    [question_id: BytesLike, answer: BytesLike, answerer: AddressLike],
    [void],
    "nonpayable"
  >;

  submitAnswerCommitment: TypedContractMethod<
    [
      question_id: BytesLike,
      answer_hash: BytesLike,
      max_previous: BigNumberish,
      _answerer: AddressLike
    ],
    [void],
    "payable"
  >;

  submitAnswerFor: TypedContractMethod<
    [
      question_id: BytesLike,
      answer: BytesLike,
      max_previous: BigNumberish,
      answerer: AddressLike
    ],
    [void],
    "payable"
  >;

  submitAnswerReveal: TypedContractMethod<
    [
      question_id: BytesLike,
      answer: BytesLike,
      nonce: BigNumberish,
      bond: BigNumberish
    ],
    [void],
    "nonpayable"
  >;

  template_hashes: TypedContractMethod<[arg0: BigNumberish], [string], "view">;

  templates: TypedContractMethod<[arg0: BigNumberish], [bigint], "view">;

  withdraw: TypedContractMethod<[], [void], "nonpayable">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "arbitrator_question_fees"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "askQuestion"
  ): TypedContractMethod<
    [
      template_id: BigNumberish,
      question: string,
      arbitrator: AddressLike,
      timeout: BigNumberish,
      opening_ts: BigNumberish,
      nonce: BigNumberish
    ],
    [string],
    "payable"
  >;
  getFunction(
    nameOrSignature: "askQuestionWithMinBond"
  ): TypedContractMethod<
    [
      template_id: BigNumberish,
      question: string,
      arbitrator: AddressLike,
      timeout: BigNumberish,
      opening_ts: BigNumberish,
      nonce: BigNumberish,
      min_bond: BigNumberish
    ],
    [string],
    "payable"
  >;
  getFunction(
    nameOrSignature: "assignWinnerAndSubmitAnswerByArbitrator"
  ): TypedContractMethod<
    [
      question_id: BytesLike,
      answer: BytesLike,
      payee_if_wrong: AddressLike,
      last_history_hash: BytesLike,
      last_answer_or_commitment_id: BytesLike,
      last_answerer: AddressLike
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "balanceOf"
  ): TypedContractMethod<[arg0: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "cancelArbitration"
  ): TypedContractMethod<[question_id: BytesLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "claimMultipleAndWithdrawBalance"
  ): TypedContractMethod<
    [
      question_ids: BytesLike[],
      lengths: BigNumberish[],
      hist_hashes: BytesLike[],
      addrs: AddressLike[],
      bonds: BigNumberish[],
      answers: BytesLike[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "claimWinnings"
  ): TypedContractMethod<
    [
      question_id: BytesLike,
      history_hashes: BytesLike[],
      addrs: AddressLike[],
      bonds: BigNumberish[],
      answers: BytesLike[]
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "commitments"
  ): TypedContractMethod<
    [arg0: BytesLike],
    [
      [bigint, boolean, string] & {
        reveal_ts: bigint;
        is_revealed: boolean;
        revealed_answer: string;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "createTemplate"
  ): TypedContractMethod<[content: string], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "createTemplateAndAskQuestion"
  ): TypedContractMethod<
    [
      content: string,
      question: string,
      arbitrator: AddressLike,
      timeout: BigNumberish,
      opening_ts: BigNumberish,
      nonce: BigNumberish
    ],
    [string],
    "payable"
  >;
  getFunction(
    nameOrSignature: "fundAnswerBounty"
  ): TypedContractMethod<[question_id: BytesLike], [void], "payable">;
  getFunction(
    nameOrSignature: "getArbitrator"
  ): TypedContractMethod<[question_id: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "getBestAnswer"
  ): TypedContractMethod<[question_id: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "getBond"
  ): TypedContractMethod<[question_id: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "getBounty"
  ): TypedContractMethod<[question_id: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "getContentHash"
  ): TypedContractMethod<[question_id: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "getFinalAnswer"
  ): TypedContractMethod<[question_id: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "getFinalAnswerIfMatches"
  ): TypedContractMethod<
    [
      question_id: BytesLike,
      content_hash: BytesLike,
      arbitrator: AddressLike,
      min_timeout: BigNumberish,
      min_bond: BigNumberish
    ],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "getFinalizeTS"
  ): TypedContractMethod<[question_id: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "getHistoryHash"
  ): TypedContractMethod<[question_id: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "getMinBond"
  ): TypedContractMethod<[question_id: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "getOpeningTS"
  ): TypedContractMethod<[question_id: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "getTimeout"
  ): TypedContractMethod<[question_id: BytesLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "isFinalized"
  ): TypedContractMethod<[question_id: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "isPendingArbitration"
  ): TypedContractMethod<[question_id: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "isSettledTooSoon"
  ): TypedContractMethod<[question_id: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "notifyOfArbitrationRequest"
  ): TypedContractMethod<
    [
      question_id: BytesLike,
      requester: AddressLike,
      max_previous: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "question_claims"
  ): TypedContractMethod<
    [arg0: BytesLike],
    [
      [string, bigint, bigint] & {
        payee: string;
        last_bond: bigint;
        queued_funds: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "questions"
  ): TypedContractMethod<
    [arg0: BytesLike],
    [
      [
        string,
        string,
        bigint,
        bigint,
        bigint,
        boolean,
        bigint,
        string,
        string,
        bigint,
        bigint
      ] & {
        content_hash: string;
        arbitrator: string;
        opening_ts: bigint;
        timeout: bigint;
        finalize_ts: bigint;
        is_pending_arbitration: boolean;
        bounty: bigint;
        best_answer: string;
        history_hash: string;
        bond: bigint;
        min_bond: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "reopenQuestion"
  ): TypedContractMethod<
    [
      template_id: BigNumberish,
      question: string,
      arbitrator: AddressLike,
      timeout: BigNumberish,
      opening_ts: BigNumberish,
      nonce: BigNumberish,
      min_bond: BigNumberish,
      reopens_question_id: BytesLike
    ],
    [string],
    "payable"
  >;
  getFunction(
    nameOrSignature: "reopened_questions"
  ): TypedContractMethod<[arg0: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "reopener_questions"
  ): TypedContractMethod<[arg0: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "resultFor"
  ): TypedContractMethod<[question_id: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "resultForOnceSettled"
  ): TypedContractMethod<[question_id: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "setQuestionFee"
  ): TypedContractMethod<[fee: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "submitAnswer"
  ): TypedContractMethod<
    [question_id: BytesLike, answer: BytesLike, max_previous: BigNumberish],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "submitAnswerByArbitrator"
  ): TypedContractMethod<
    [question_id: BytesLike, answer: BytesLike, answerer: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "submitAnswerCommitment"
  ): TypedContractMethod<
    [
      question_id: BytesLike,
      answer_hash: BytesLike,
      max_previous: BigNumberish,
      _answerer: AddressLike
    ],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "submitAnswerFor"
  ): TypedContractMethod<
    [
      question_id: BytesLike,
      answer: BytesLike,
      max_previous: BigNumberish,
      answerer: AddressLike
    ],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "submitAnswerReveal"
  ): TypedContractMethod<
    [
      question_id: BytesLike,
      answer: BytesLike,
      nonce: BigNumberish,
      bond: BigNumberish
    ],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "template_hashes"
  ): TypedContractMethod<[arg0: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "templates"
  ): TypedContractMethod<[arg0: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "withdraw"
  ): TypedContractMethod<[], [void], "nonpayable">;

  getEvent(
    key: "LogAnswerReveal"
  ): TypedContractEvent<
    LogAnswerRevealEvent.InputTuple,
    LogAnswerRevealEvent.OutputTuple,
    LogAnswerRevealEvent.OutputObject
  >;
  getEvent(
    key: "LogCancelArbitration"
  ): TypedContractEvent<
    LogCancelArbitrationEvent.InputTuple,
    LogCancelArbitrationEvent.OutputTuple,
    LogCancelArbitrationEvent.OutputObject
  >;
  getEvent(
    key: "LogClaim"
  ): TypedContractEvent<
    LogClaimEvent.InputTuple,
    LogClaimEvent.OutputTuple,
    LogClaimEvent.OutputObject
  >;
  getEvent(
    key: "LogFinalize"
  ): TypedContractEvent<
    LogFinalizeEvent.InputTuple,
    LogFinalizeEvent.OutputTuple,
    LogFinalizeEvent.OutputObject
  >;
  getEvent(
    key: "LogFundAnswerBounty"
  ): TypedContractEvent<
    LogFundAnswerBountyEvent.InputTuple,
    LogFundAnswerBountyEvent.OutputTuple,
    LogFundAnswerBountyEvent.OutputObject
  >;
  getEvent(
    key: "LogMinimumBond"
  ): TypedContractEvent<
    LogMinimumBondEvent.InputTuple,
    LogMinimumBondEvent.OutputTuple,
    LogMinimumBondEvent.OutputObject
  >;
  getEvent(
    key: "LogNewAnswer"
  ): TypedContractEvent<
    LogNewAnswerEvent.InputTuple,
    LogNewAnswerEvent.OutputTuple,
    LogNewAnswerEvent.OutputObject
  >;
  getEvent(
    key: "LogNewQuestion"
  ): TypedContractEvent<
    LogNewQuestionEvent.InputTuple,
    LogNewQuestionEvent.OutputTuple,
    LogNewQuestionEvent.OutputObject
  >;
  getEvent(
    key: "LogNewTemplate"
  ): TypedContractEvent<
    LogNewTemplateEvent.InputTuple,
    LogNewTemplateEvent.OutputTuple,
    LogNewTemplateEvent.OutputObject
  >;
  getEvent(
    key: "LogNotifyOfArbitrationRequest"
  ): TypedContractEvent<
    LogNotifyOfArbitrationRequestEvent.InputTuple,
    LogNotifyOfArbitrationRequestEvent.OutputTuple,
    LogNotifyOfArbitrationRequestEvent.OutputObject
  >;
  getEvent(
    key: "LogReopenQuestion"
  ): TypedContractEvent<
    LogReopenQuestionEvent.InputTuple,
    LogReopenQuestionEvent.OutputTuple,
    LogReopenQuestionEvent.OutputObject
  >;
  getEvent(
    key: "LogSetQuestionFee"
  ): TypedContractEvent<
    LogSetQuestionFeeEvent.InputTuple,
    LogSetQuestionFeeEvent.OutputTuple,
    LogSetQuestionFeeEvent.OutputObject
  >;

  filters: {
    "LogAnswerReveal(bytes32,address,bytes32,bytes32,uint256,uint256)": TypedContractEvent<
      LogAnswerRevealEvent.InputTuple,
      LogAnswerRevealEvent.OutputTuple,
      LogAnswerRevealEvent.OutputObject
    >;
    LogAnswerReveal: TypedContractEvent<
      LogAnswerRevealEvent.InputTuple,
      LogAnswerRevealEvent.OutputTuple,
      LogAnswerRevealEvent.OutputObject
    >;

    "LogCancelArbitration(bytes32)": TypedContractEvent<
      LogCancelArbitrationEvent.InputTuple,
      LogCancelArbitrationEvent.OutputTuple,
      LogCancelArbitrationEvent.OutputObject
    >;
    LogCancelArbitration: TypedContractEvent<
      LogCancelArbitrationEvent.InputTuple,
      LogCancelArbitrationEvent.OutputTuple,
      LogCancelArbitrationEvent.OutputObject
    >;

    "LogClaim(bytes32,address,uint256)": TypedContractEvent<
      LogClaimEvent.InputTuple,
      LogClaimEvent.OutputTuple,
      LogClaimEvent.OutputObject
    >;
    LogClaim: TypedContractEvent<
      LogClaimEvent.InputTuple,
      LogClaimEvent.OutputTuple,
      LogClaimEvent.OutputObject
    >;

    "LogFinalize(bytes32,bytes32)": TypedContractEvent<
      LogFinalizeEvent.InputTuple,
      LogFinalizeEvent.OutputTuple,
      LogFinalizeEvent.OutputObject
    >;
    LogFinalize: TypedContractEvent<
      LogFinalizeEvent.InputTuple,
      LogFinalizeEvent.OutputTuple,
      LogFinalizeEvent.OutputObject
    >;

    "LogFundAnswerBounty(bytes32,uint256,uint256,address)": TypedContractEvent<
      LogFundAnswerBountyEvent.InputTuple,
      LogFundAnswerBountyEvent.OutputTuple,
      LogFundAnswerBountyEvent.OutputObject
    >;
    LogFundAnswerBounty: TypedContractEvent<
      LogFundAnswerBountyEvent.InputTuple,
      LogFundAnswerBountyEvent.OutputTuple,
      LogFundAnswerBountyEvent.OutputObject
    >;

    "LogMinimumBond(bytes32,uint256)": TypedContractEvent<
      LogMinimumBondEvent.InputTuple,
      LogMinimumBondEvent.OutputTuple,
      LogMinimumBondEvent.OutputObject
    >;
    LogMinimumBond: TypedContractEvent<
      LogMinimumBondEvent.InputTuple,
      LogMinimumBondEvent.OutputTuple,
      LogMinimumBondEvent.OutputObject
    >;

    "LogNewAnswer(bytes32,bytes32,bytes32,address,uint256,uint256,bool)": TypedContractEvent<
      LogNewAnswerEvent.InputTuple,
      LogNewAnswerEvent.OutputTuple,
      LogNewAnswerEvent.OutputObject
    >;
    LogNewAnswer: TypedContractEvent<
      LogNewAnswerEvent.InputTuple,
      LogNewAnswerEvent.OutputTuple,
      LogNewAnswerEvent.OutputObject
    >;

    "LogNewQuestion(bytes32,address,uint256,string,bytes32,address,uint32,uint32,uint256,uint256)": TypedContractEvent<
      LogNewQuestionEvent.InputTuple,
      LogNewQuestionEvent.OutputTuple,
      LogNewQuestionEvent.OutputObject
    >;
    LogNewQuestion: TypedContractEvent<
      LogNewQuestionEvent.InputTuple,
      LogNewQuestionEvent.OutputTuple,
      LogNewQuestionEvent.OutputObject
    >;

    "LogNewTemplate(uint256,address,string)": TypedContractEvent<
      LogNewTemplateEvent.InputTuple,
      LogNewTemplateEvent.OutputTuple,
      LogNewTemplateEvent.OutputObject
    >;
    LogNewTemplate: TypedContractEvent<
      LogNewTemplateEvent.InputTuple,
      LogNewTemplateEvent.OutputTuple,
      LogNewTemplateEvent.OutputObject
    >;

    "LogNotifyOfArbitrationRequest(bytes32,address)": TypedContractEvent<
      LogNotifyOfArbitrationRequestEvent.InputTuple,
      LogNotifyOfArbitrationRequestEvent.OutputTuple,
      LogNotifyOfArbitrationRequestEvent.OutputObject
    >;
    LogNotifyOfArbitrationRequest: TypedContractEvent<
      LogNotifyOfArbitrationRequestEvent.InputTuple,
      LogNotifyOfArbitrationRequestEvent.OutputTuple,
      LogNotifyOfArbitrationRequestEvent.OutputObject
    >;

    "LogReopenQuestion(bytes32,bytes32)": TypedContractEvent<
      LogReopenQuestionEvent.InputTuple,
      LogReopenQuestionEvent.OutputTuple,
      LogReopenQuestionEvent.OutputObject
    >;
    LogReopenQuestion: TypedContractEvent<
      LogReopenQuestionEvent.InputTuple,
      LogReopenQuestionEvent.OutputTuple,
      LogReopenQuestionEvent.OutputObject
    >;

    "LogSetQuestionFee(address,uint256)": TypedContractEvent<
      LogSetQuestionFeeEvent.InputTuple,
      LogSetQuestionFeeEvent.OutputTuple,
      LogSetQuestionFeeEvent.OutputObject
    >;
    LogSetQuestionFee: TypedContractEvent<
      LogSetQuestionFeeEvent.InputTuple,
      LogSetQuestionFeeEvent.OutputTuple,
      LogSetQuestionFeeEvent.OutputObject
    >;
  };
}
