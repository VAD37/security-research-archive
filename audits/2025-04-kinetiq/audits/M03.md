# `StakingManager` withdrawal ignores 1-day lockup period on L1 HyperCore, causing failed operations

## Summary

Delegating to a validator requires a 1-day lockup period.  
The `StakingManager` on L2 processes withdrawal requests without verifying if L1 HyperCore's 1-day lockup period for delegations has released sufficient tokens.
This oversight causes undelegate transactions on L1 to fail, leading to balance mismatches between L1 and L2, requiring admin intervention to rebalance.

## Impact

Any failed operation/transaction sent to L1 results in a mismatch between the tracking balances of L1 HyperCore and L2 EVM.

- Balance mismatches prevent unstaking from the Staking Balance susccessfully.
- Admin intervention is required to manually rebalance the system.

This bug can be triggered by any user depositing and withdrawing within 24 hours if the stake amount exceeds the total unlocked delegation.

## Finding Description

[Official Docs](https://hyperliquid.gitbook.io/hyperliquid-docs/hypercore/staking) state that L1 HyperCore requires a 1-day lockup period for delegation. Undelegation can be partial or full after the lockup period.

When processing the withdrawal queue, the undelegate operation does not verify if Layer 1 HyperCore has released the delegation from lockup. This check can be implemented using the `L1Read.sol` contract, which is currently [missing here](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L688-L702).

```solidity
function _processL1Withdrawals(uint256 batchSize) internal returns (uint256) {
    // Process withdrawals
    for (uint256 i = _withdrawalProcessingIndex; i < endIndex; i++) {
        L1Operation memory op = _pendingWithdrawals[i];
        require(op.amount <= type(uint64).max, "Amount exceeds uint64 max");

        // Send withdrawal toecimals) //@audit M missing L1Read for delegation summary. It is unclear if L1 already unlock enough token to undelegate
        l1Write.sendTokenDelegate(op.validator, uint64(op.amount), true);//@undelegate from staking. true == undelegate, false = delegate

        // Only call sendCWithdrawal for user withdrawals
        if (op.operationType == OperationType.UserWithdrawal) {
            l1Write.sendCWithdrawal(uint64(op.amount));
        }

        emit L1DelegationProcessed(address(this), op.validator, op.amount, op.operationType);
        processedCount++;
    }
```

The L2 operation `l1Write.sendTokenDelegate(op.validator, uint64(op.amount), true)` triggers an event on L1. If the previous delegation has not been unlocked, the L1 transaction will revert.

## POC

Scenario: User deposit then withdraw within a few hours. The `StakingManager` have only this single user or this single user volume > 50% total staking deposit.

1. **User Deposit**:
   - User stakes HYPE on L2 using `StakingManager.stake()`.
   - Deposit is added to the pending queue.
   - L2 processes the deposit and sends a delegate transaction to L1.
     - [Ref1: distribute stake move HYPE from L2 to L1 Spot Balance](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L247)
     - [Ref2: create deposit pending queue and Staking HYPE from Spot Balance to Staking Balance](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L484)
     - [Ref3: execute pending queue by delegate to validator](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L741)

2. **User Withdrawal**:
   - User calls `StakingManager.queueWithdrawal()` to unstake within a few minutes of depositing, creating a withdrawal request.
     - [Ref](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L293)
   - L2 processes the withdrawal and sends an undelegate transaction to L1.
     - [Ref](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L692-L693)
   - HYPE tokens are transferred from the Staking Balance to the Spot Balance.
     - [Ref](https://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L697)

3. **Failure Scenario**:
   - Since the 1-day lockup period on L1 has not elapsed, the undelegate transaction fails.
   - This causes `l1Write.sendCWithdrawal()` (unstake from Staking balance to Spot balance in 7 days) to fail, preventing token unstaking.
   - Users cannot claim HYPE tokens after the 7-day waiting period without admin intervention.

## Impact Explanation

If the undelegate command on L1 fails, the `l1Write.sendCWithdrawal()` operation also fails, preventing the unstaking of tokens from the Staking Balance.

```solidity
// Process withdrawals
for (uint256 i = _withdrawalProcessingIndex; i < endIndex; i++) {
    L1Operation memory op = _pendingWithdrawals[i];
    require(op.amount <= type(uint64).max, "Amount exceeds uint64 max");

    // Send withdrawal to L1 (8 decimals)
    l1Write.sendTokenDelegate(op.validator, uint64(op.amount), true); //@ L1 failure occurs here

    // Only call sendCWithdrawal for user withdrawals
    if (op.operationType == OperationType.UserWithdrawal) {
        l1Write.sendCWithdrawal(uint64(op.amount)); //@ User withdrawal operation fails here
    }
}
```

Without early admin intervention to reset undelegation and restart unstaking, users will be unable to claim HYPE tokens from the Staking Balance after 7 days. The contract will not transfer tokens from the Staking Balance to the Spot Balance, resulting in failed claims.

## Recommended Mitigation Steps

Since the Staking Manager is a shared pool, there is no need to add complexity by enforcing a 1-day delay for each user's deposit and withdrawal.

Instead, implement a check in the `L1Read.sol` contract to ensure sufficient tokens are unlocked before processing withdrawals.

```solidity
function _queueL1Operation(address validator, uint256 amount, OperationType operationType) internal {
    // Create the L1 operation
    L1Operation memory operation = L1Operation({
        validator: validator,
        amount: amount,
        operationType: operationType
    });

    // Add to the appropriate queue based on operation type
    bool isWithdrawal = operationType == OperationType.UserWithdrawal ||
        operationType == OperationType.RebalanceWithdrawal;

    if (isWithdrawal) {
        _pendingWithdrawals.push(operation);
        //@Fix: Check if enough tokens are unlocked for undelegation (only for UserWithdrawal operations)
        if (operationType == OperationType.UserWithdrawal) {
            uint256 available = L1Read.delegatorSummary(address(this)).undelegated;
            require(available >= amount, "Not enough unlocked tokens to undelegate.");
        }
    } else {
        _pendingDeposits.push(operation);
    }

    emit L1DelegationQueued(address(this), validator, amount, operationType);
}
```
