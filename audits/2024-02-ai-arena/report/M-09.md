# `RankedBattle.claimNRN()` and `MergingPool.claimRewards()` Out Of Gas. User transaction will reach 30M block gas limit after ~ 6000 battle rounds

`RankedBattle.claimNRN()` and `MergingPool.claimRewards()` code are gas inefficient that loop through all rounds to find rewards to claim.

For L2 game, if the game start new round every 1 hour. After 6000 rounds, or 245 days, new user claiming rewards transaction will reach 30M block gas limit.

## Impact

After 6000 rounds, no new user will be able to claim rewards anymore. It reach block gas limit and no longer able to claim rewards.

## Proof of Concept

Because after user stake token. Stake will carry on to new rounds. User can passively earn points if someone battle them.
So looping through every single round to check if user have rewards that round make sense

But it extremely really inefficient logic.

This loop run every time new user claim rewards.
This mean if current round is 500.
New user have to loop through 500 previous rounds to check if they have any reward.

Running below foundry test to simulate this. After 6000 rounds, it cost user 30M gas to just call `claimNRN()` the first time.
Same things with `MergingPool.claimRewards()`. Same logic, same problem.

Modify some file to run these test.

### `test\RankedBattle.t.sol`

```solidity
        /// @notice Test 2 accounts staking, winning a battle, setting a new round and claiming NRN for the previous round.
    function testClaimNRNGas() public {
        //Set round to 4000
        _rankedBattleContract.debugSetNewRound(6000);
        address staker = vm.addr(3);
        //print gas report
        uint gasLeft = gasleft();
        vm.prank(staker);        
        _rankedBattleContract.claimNRN();
        console.log("Gas used: ", gasLeft - gasleft());
    }
```

### `src\RankedBattle.sol`

```solidity
    function debugSetNewRound(uint setRound) external {
        require(isAdmin[msg.sender]);
        roundId = setRound;
        _stakeAtRiskInstance.setNewRound(roundId);//@audit-ok M global staked does not update when stake at risk is removed
        rankedNrnDistribution[roundId] = rankedNrnDistribution[roundId - 1];
    }
    //@Edit
    function claimNRN() external {
        require(numRoundsClaimed[msg.sender] < roundId, "Already claimed NRNs for this period");//@audit M out of gas claimNRN after 4000 rounds. Tested through foundry
        uint256 claimableNRN = 0;
        uint256 nrnDistribution;
        uint32 lowerBound = numRoundsClaimed[msg.sender];
        for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {
            nrnDistribution = getNrnDistribution(currentRound);
            if(totalAccumulatedPoints[currentRound]>0)
                claimableNRN += (
                    accumulatedPointsPerAddress[msg.sender][currentRound] * nrnDistribution   
                ) / totalAccumulatedPoints[currentRound];
            else claimableNRN += 1; //@for debug gas
            numRoundsClaimed[msg.sender] += 1;
        }
        if (claimableNRN > 0) {
            amountClaimed[msg.sender] += claimableNRN;
            _neuronInstance.mint(msg.sender, claimableNRN);
            emit Claimed(msg.sender, claimableNRN);
        }
    }
```

### Final result

```
Running 1 test for test/RankedBattle.t.sol:RankedBattleTest
[PASS] testClaimNRNGas() (gas: 31636965)
Logs:
  Gas used:  31550102
```

## Tools Used

<https://github.com/code-423n4/2024-02-ai-arena/blob/f2952187a8afc44ee6adc28769657717b498b7d4/src/RankedBattle.sol#L292-L311>
<https://github.com/code-423n4/2024-02-ai-arena/blob/f2952187a8afc44ee6adc28769657717b498b7d4/src/MergingPool.sol#L139-L167>

## Recommended Mitigation Steps

Limit loop to 1000 per transaction.

```solidity
    /// @notice Claims NRN tokens for the specified rounds.
    /// @dev Caller can only claim once per round.
    function claimNRN() external {
        require(numRoundsClaimed[msg.sender] < roundId, "Already claimed NRNs for this period");//@audit M out of gas claimNRN after 4000 rounds. Tested through foundry
        uint256 claimableNRN = 0;
        uint256 nrnDistribution;
        uint32 lowerBound = numRoundsClaimed[msg.sender];
+        uint roundLoop = math.Max(roundId, lowerBound + 1000);
+        for (uint32 currentRound = lowerBound; currentRound < roundLoop; currentRound++) {
            nrnDistribution = getNrnDistribution(currentRound);
            claimableNRN += (
                accumulatedPointsPerAddress[msg.sender][currentRound] * nrnDistribution   
            ) / totalAccumulatedPoints[currentRound];
        }
+        numRoundsClaimed[msg.sender] += roundLoop;
        if (claimableNRN > 0) {
            amountClaimed[msg.sender] += claimableNRN;
            _neuronInstance.mint(msg.sender, claimableNRN);
            emit Claimed(msg.sender, claimableNRN);
        }
    }
```
