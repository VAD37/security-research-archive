# `attributeProbabilities` non total 100 issue. Rolling attribute 99 out of 99 expect maximum rarityIndex but `AIArenaHelper.dnaToIndex()` return undefined index 0. Allowing undefined behavior

Dna rolling `rarityRank` from `0 -> 99`.
Sum of `AIArenaHelper.attributeProbabilities[]` array total is not 100.
This cause issue when rolling DNA, because probability does not map to 100.

Using this logic: The higher rarity score, the better physical attributeIndex you got, or simply higher rarity == better.

As Dendroid (cheapest NFT) have dna 0 and `rarityRank == 0` by default. It also return attributeIndex == 1.
`dnaToIndex()` always return `attributeProbabilityIndex` with minimum index 1.

But using test config, sometimes.
If you roll 90+ rarity score, you get `attributeIndex == 0` which is undefined behavior.
The expected behavior is to get attributeIndex 6 or it rolling back to 1.

## Impact

DNA roll for Physical Attribute index using ladder array, fail to get correct index when total score of `attrProbabilities[]` array less than 99 or more than 100.
Causing undefined behavior.

## Proof of Concept

`dnaToIndex()` is called when dna is convert to rarityRank.
`rarityRank` range from [0 to 99.](https://github.com/code-423n4/2024-02-ai-arena/blob/f2952187a8afc44ee6adc28769657717b498b7d4/src/AiArenaHelper.sol#L107)

```solidity
    uint256 rarityRank = (dna / attributeToDnaDivisor[attributes[i]]) % 100;
```

Look at how `dnaToIndex()` logic convert rarityRank to attribute index function is faulty.

```
    function dnaToIndex(uint256 generation, uint256 rarityRank, string memory attribute) //@note most of dendroid attributeProbabilityIndex is 1. if rarity overshoot 95%. it return 0
        public 
        view 
        returns (uint256 attributeProbabilityIndex) //@audit M dnaToIndex do have NULL value 0. No clue what this index stand for
    {
        uint8[] memory attrProbabilities = getAttributeProbabilities(generation, attribute);//@head: [25, 25, 13, 13, 9, 9] +=94
        //@body : [25, 25, 13, 13, 9, 23] +=108
        uint256 cumProb = 0;//@hands : [25, 25, 13, 13, 9, 1] +=86
        uint256 attrProbabilitiesLength = attrProbabilities.length;
        for (uint8 i = 0; i < attrProbabilitiesLength; i++) {//@this array default 6 or possible more
            cumProb += attrProbabilities[i];
            if (cumProb >= rarityRank) {//@rarityRank 0-99
                attributeProbabilityIndex = i + 1;
                break;
            }
        }
        return attributeProbabilityIndex;//@cum prob total less than 95. and rarity roll is 99. it return 0 
    }
```

`attrProbabilities[]` array is probability ladder.
For example: This is head attribute array `//@head: [25, 25, 13, 13, 9, 9]`. Total: 94
You roll 3, you get attributeIndex 1.
You roll 50, you get attributeIndex 2.
You roll 90, you get attributeIndex 6.

But when you roll 99, you get default attributeIndex 0.
For-loop case reach final index but because `cumProb < total:94`, it never save `attributeProbabilityIndex` to 6.

The issue here is `rarityRank` should get remainder of 94 or total of `attrProbabilities[]` array. not `% 100` by default

## Tools Used

<https://github.com/code-423n4/2024-02-ai-arena/blob/f2952187a8afc44ee6adc28769657717b498b7d4/src/AiArenaHelper.sol#L169-L186>

## Recommended Mitigation Steps

Temp fix.

```solidity

    function createPhysicalAttributes(
        uint256 dna, 
        uint8 generation, 
        uint8 iconsType, 
        bool dendroidBool
    ) 
        external 
        view 
        returns (FighterOps.FighterPhysicalAttributes memory) 
    {
        if (dendroidBool) {
            return FighterOps.FighterPhysicalAttributes(99, 99, 99, 99, 99, 99);
        } else {
            uint256[] memory finalAttributeProbabilityIndexes = new uint[](attributes.length);

            uint256 attributesLength = attributes.length;//0: head, 1: eyes, 2: mouth, 3: body, 4: hands, 5: feet
            for (uint8 i = 0; i < attributesLength; i++) {
                if (
                  i == 0 && iconsType == 2 || // Custom icons head (beta helmet)
                  i == 1 && iconsType > 0 || // Custom icons eyes (red diamond)//@audit M how you suppose to change NFT eye later? If project include more cosmetic change?
                  i == 4 && iconsType == 3 // Custom icons hands (bowling ball)
                ) {
                    finalAttributeProbabilityIndexes[i] = 50;
                } else {//@ dnaDivisor [2, 3, 5, 7, 11, 13] or head: 2, eyes: 3, mouth: 5, body: 7, hands: 11, feet: 13
+++                    uint256 modular = getTotalAttributeProbabilities(generation,attributes[i]);
+++                    uint256 rarityRank = (dna / attributeToDnaDivisor[attributes[i]]) % modular;//@rarityRank range from 0 to 99
                    uint256 attributeIndex = dnaToIndex(generation, rarityRank, attributes[i]);
                    finalAttributeProbabilityIndexes[i] = attributeIndex;
                }
            }
            return FighterOps.FighterPhysicalAttributes(
                finalAttributeProbabilityIndexes[0],//@note final attribute index always smaller than 6. range 1-6. suppose not 0
                finalAttributeProbabilityIndexes[1],
                finalAttributeProbabilityIndexes[2],
                finalAttributeProbabilityIndexes[3],
                finalAttributeProbabilityIndexes[4],
                finalAttributeProbabilityIndexes[5]
            );
        }
    }
    function getTotalAttributeProbabilities(uint8 generation, string memory attribute) public view returns (uint256) {
        uint8[] memory attrProbabilities = getAttributeProbabilities(generation, attribute);
        uint256 total = 0;
        for (uint8 i = 0; i < attrProbabilities.length; i++) {
            total += attrProbabilities[i];
        }
        return total;
    }
```
