The `burnShares()` function in the ERC4626 standard introduces a potential for slippage attacks, distinct from the common donation-based slippage attack.
Exploter can manipulate share prices by burning their shares, inflating the value of remaining shares.

Noya's admin-controlled deposit queuing process, designed to prevent donation attacks by having healthy a balance between minted shares and vault token balance, is vulnerable to exploit by using multiple fake accounts trying to deposit first.

## Impact

ERC4626 vault slippage attack with `burnShares()`.

Require Emergency shutdown to rescue.
If not discoverable in 6h withdrawal waiting time, attacker can steal other people deposit funds.

## Proof of Concept

Noyaâ€™s system utilizes a deposit queue controlled by the Vault Manager, who dictates when new shares are minted. Attackers can gain an advantageous position by distributing their deposits across multiple fake accounts to dominate the queue's initial slots.
<https://github.com/code-423n4/2024-04-noya/blob/9c79b332eff82011dcfa1e8fd51bad805159d758/contracts/accountingManager/AccountingManager.sol#L199-L298>

By becoming the initial depositors, these attackers can dictate the share pricing mechanism. The calculation of shares is based on the formula:
`share = depositAmount * Supply / TVL`

Where `TVL` is the total value locked in the vault, and `Supply` is the total supply of shares.
<https://github.com/code-423n4/2024-04-noya/blob/9c79b332eff82011dcfa1e8fd51bad805159d758/contracts/accountingManager/AccountingManager.sol#L239>

Typically, donation slippage exploiter would mint a minimal amount of shares to keep the supply low, then either donate a significant token amount to inflate the TVL or burn most of their shares to reduce the supply drastically.

For example, mint 1e1 USDC for 1e1 share. The donate 1e10 USDC to make TVL 1e10.
Share price for new deposit will be `share = depositUSDC * 1e1/1e10`. If next user deposit any less than 10000e6 USDC, their share rounded down to 0. Which effectively donate token to vault,attacker.

Because `burnShares()` is public, attackers do not need to donate tokens to the vault
They can merely burn their shares to reduce the total supply, inflating the price of the remaining shares.

The next depositor would find that `previewDeposit()` returns 0 shares for small deposit amounts, effectively stealing their deposit.

## Tools Used

## Recommended Mitigation Steps

The only purpose of `burnShares()` is to give back fee from `NoyaFeeReceiver` back to user.
This can be done with `withdraw()` function instead. By donate money back to vault address. Albeit much slower than direct transfer.

```solidity
    function withdrawShares(uint256 amount) external onlyOwner {
        AccountingManager(accountingManager).withdraw(amount, receiver);
    }

    function burnShares(uint256 amount) external onlyOwner {
---        AccountingManager(accountingManager).burnShares(amount);
+++     AccountingManager(accountingManager).withdraw(amount, address(accountingManager));
    }
```
