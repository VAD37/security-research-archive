# Keeper from different vault can use each other funds despite have no permission in. Use `BalancerFlashloan` to bypass permission check

`Registry.sol` keep track each vault have its own keeper address, but there is only one flashloan address.

It is expected that each keeperContract can only interact with its own vault.
But `BalancerFlashLoan` do not check call target address.
This allow Keepers from different vaults to interact with other vaults and bypassing the permission check.

## Impact

A keeper from one vault can use flashloan to interact with other vaults, bypassing vault permission check which is not intended.

## Proof of Concept

Here is how each vault Manager permission is checked.
Flashloan contract have unique permission and considered a Manager.

```solidity
    modifier onlyManager() {//@audit R gov onlyManager include flashloan which is BalancerFlashLoan
        (,,, address keeperContract,, address emergencyManager) = registry.getGovernanceAddresses(vaultId);
        if (!(msg.sender == keeperContract || msg.sender == emergencyManager || msg.sender == registry.flashLoan())) {
            revert NoyaGovernance_Unauthorized(msg.sender);
        }
        _;
    }
```

In `BalancerFlashLoan` callback, it check only keeper contract can pass permission check.
<https://github.com/code-423n4/2024-04-noya/blob/9c79b332eff82011dcfa1e8fd51bad805159d758/contracts/connectors/BalancerFlashLoan.sol#L69-L71>

```solidity
        (,,, address keeperContract,, address emergencyManager) = registry.getGovernanceAddresses(vaultId);//@audit-ok keeper only
        if (!(caller == keeperContract)) {//@audit L failed to check emergency manager in flashloan callback.
            revert Unauthorized(caller);
```

But later there is no address check, allowing Keeper call to any address which include other vaults.

```solidity
    for (uint256 i = 0; i < destinationConnector.length; i++) {//@ make call to a list of address with data and gas
        // execute the transactions
        (bool success,) = destinationConnector[i].call{ value: 0, gas: gas[i] }(callingData[i]);//@audit L how do keepers cleanup stuck token and approval ?
        require(success, "BalancerFlashLoan: Flash loan failed");
    }
```

All other vaults connector and AccountingManager all use the same `onlyManager()` modifier.
`onlyManager()` allowing any call from flashloan contract going through.
This result in Keepers can call any connector to swap token, deposit, withdraw, or even transfer token to other vaults.

## Tools Used

<https://github.com/code-423n4/2024-04-noya/blob/9c79b332eff82011dcfa1e8fd51bad805159d758/contracts/governance/NoyaGovernanceBase.sol#L31-L37>

## Recommended Mitigation Steps

Included `Registry.isAnActiveConnector` check

```solidity

            for (uint256 i = 0; i < destinationConnector.length; i++) {
+++             require(registry.isAnActiveConnector(vaultId, destinationConnector[i]), "BalancerFlashLoan: Invalid connector");
                (bool success,) = destinationConnector[i].call{ value: 0, gas: gas[i] }(callingData[i]);
                require(success, "BalancerFlashLoan: Flash loan failed");
            }
```
