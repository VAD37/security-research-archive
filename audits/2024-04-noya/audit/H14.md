# Uniswap/Pancake Connector missing earned fee in TVL calculation

## Impact

Missing UniswapV3 position earned fee cause TVL calculation to be inaccurate.

Causing undervalue of user share price during deposit and withdraw until Vault Manager claim earned fee from Uniswap.

This also apply to other Connector holding Pancake,UniswapV2 liquidity.

## Proof of Concept

For brevity this issue will focus on UniswapV3 connector.

<https://github.com/code-423n4/2024-04-noya/blob/9c79b332eff82011dcfa1e8fd51bad805159d758/contracts/connectors/UNIv3Connector.sol#L127-L150>

`UNIv3Connector._getPositionTVL()` ignore `feeGrowthInside0LastX128` and `feeGrowthInside1LastX128` from uniswap position. These variable is used to calculate how much fee already earned.

## Tools Used

## Recommended Mitigation Steps

Include uncollected fee calculation fixed the issue.
Here is sample code for reference

```solidity

    function _getPositionTVL(HoldingPI memory p, address base) public view override returns (uint256 tvl) {
        PositionBP memory positionInfo = registry.getPositionBP(vaultId, p.positionId);
        uint256 tokenId = abi.decode(p.data, (uint256));
        (address token0, address token1) = abi.decode(positionInfo.data, (address, address));
        uint256 amount0;
        uint256 amount1;
        (int24 tL, int24 tU, uint24 fee) = abi.decode(p.additionalData, (int24, int24, uint24));
        {
            IUniswapV3Pool pool = IUniswapV3Pool(factory.getPool(token0, token1, fee));
            bytes32 key = keccak256(abi.encodePacked(positionManager, tL, tU));

            (uint128 liquidity,,, uint128 tokensOwed0, uint128 tokensOwed1) = pool.positions(key);

            (uint160 sqrtPriceX96,,,,,,) = pool.slot0();
            (amount0, amount1) = LiquidityAmounts.getAmountsForLiquidity(
                sqrtPriceX96, TickMath.getSqrtRatioAtTick(tL), TickMath.getSqrtRatioAtTick(tU), liquidity
            );
            amount0 += tokensOwed0;
            amount1 += tokensOwed1;
        }
        //@audit H14 UniswapV3 missing TVL feegrowth for position.
        {
            (uint128 fee0, uint128 fee1) = getUncollectedFee(p);
            amount0 += fee0;
            amount1 += fee1;
        }

        tvl += valueOracle.getValue(token0, base, amount0);
        tvl += valueOracle.getValue(token1, base, amount1);
    }

    uint256 private constant Q128 = 2 ** 128;
    function getUncollectedFee(HoldingPI memory p) returns(uint128 fees0, uint128 fees1) {
        MintParams p;//lower,upper tick cached from openPosition()

        (,, uint256 lowerFeeGrowthOutside0X128, uint256 lowerFeeGrowthOutside1X128,,,,) = pool.ticks(p.tickLower);
        (,, uint256 upperFeeGrowthOutside0X128, uint256 upperFeeGrowthOutside1X128,,,,) = pool.ticks(p.tickUpper);

        // allow overflow - this is as designed by uniswap - see PositionValue library (for solidity < 0.8)
        unchecked {
            if (tickCurrent < tickLower) {
                feeGrowthInside0X128 = lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;
                feeGrowthInside1X128 = lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;
            } else if (tickCurrent < tickUpper) {
                feeGrowthInside0X128 = feeGrowthGlobal0X128 - lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;
                feeGrowthInside1X128 = feeGrowthGlobal1X128 - lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;
            } else {
                feeGrowthInside0X128 = upperFeeGrowthOutside0X128 - lowerFeeGrowthOutside0X128;
                feeGrowthInside1X128 = upperFeeGrowthOutside1X128 - lowerFeeGrowthOutside1X128;
            }
        }

                // allow overflow - this is as designed by uniswap - see PositionValue library (for solidity < 0.8)
        uint256 feeGrowth0;
        uint256 feeGrowth1;
        unchecked {
            feeGrowth0 = feeGrowthInside0LastX128 - position.feeGrowthInside0LastX128;
            feeGrowth1 = feeGrowthInside1LastX128 - position.feeGrowthInside1LastX128;
        }

        fees0 = uint128(FullMath.mulDiv(feeGrowth0, position.liquidity, Q128));
        fees1 = uint128(FullMath.mulDiv(feeGrowth1, position.liquidity, Q128));
    }
```
