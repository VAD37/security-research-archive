# DOS `BalancerFlashloan.sol` by deposit small amount of token to prevent balance check

Keeper contracts can make flashloan call to BalancerContract.

There is this require check `require(tokens[i].balanceOf(address(this)) == 0, "BalancerFlashLoan: Flash loan extra tokens");` in flashloan callback.
This check will fail if the flashloan token balance is not zero.

And flashloan callback only handle exactly amount of token it receive from Balancer. It ignore current contract balance.
So anyone transfer small amount of token to this contract can prevent final require check from passing.

## Impact

DOS `BalancerFlashloan.sol`. Require new contract deployment to fix.

## Proof of Concept

Here is what flashloan callback do.
<https://github.com/code-423n4/2024-04-noya/blob/9c79b332eff82011dcfa1e8fd51bad805159d758/contracts/connectors/BalancerFlashLoan.sol#L54-L94>

Check only Keepers contract can call flashloan callback.
<https://github.com/code-423n4/2024-04-noya/blob/9c79b332eff82011dcfa1e8fd51bad805159d758/contracts/connectors/BalancerFlashLoan.sol#L70-L72>

transfer all flashloan token to BaseConnector

```solidity
            for (uint256 i = 0; i < tokens.length; i++) {//@transfer flashloan token to single BaseConnector
                // send the tokens to the receiver
                tokens[i].safeTransfer(receiver, amounts[i]);
                amounts[i] = amounts[i] + feeAmounts[i];
            }
```

Make external call to external address

```solidity
            for (uint256 i = 0; i < destinationConnector.length; i++) {//@ make call to a list of address with data and gas
                // execute the transactions
                (bool success,) = destinationConnector[i].call{ value: 0, gas: gas[i] }(callingData[i]);
                require(success, "BalancerFlashLoan: Flash loan failed");
            }
```

Request BaseConnector to send back flashloan token + fee

```solidity
    for (uint256 i = 0; i < tokens.length; i++) {//@ take token back from Connector + fee.
        // send the tokens back to this contract
        BaseConnector(receiver).sendTokensToTrustedAddress(address(tokens[i]), amounts[i], address(this), "");
    }
```

Then refund flashloan token to Balancer exactly requested amount.

```solidity
            for (uint256 i = 0; i < tokens.length; i++) {//@refund balancer vault with fee
            // send the tokens back to the vault
            tokens[i].safeTransfer(msg.sender, amounts[i]);//@audit M DOS flashloan by keepers if someone send some tokens to this contract to exploit null balance check.
            require(tokens[i].balanceOf(address(this)) == 0, "BalancerFlashLoan: Flash loan extra tokens");
        }
```

## Tools Used

## Recommended Mitigation Steps

It is reasonable to have rescue funds in the contract to handle such situation.

```solidity
    function rescueFunds(address _token, uint256 _amount) external onlyOwner {
        IERC20(_token).safeTransfer(msg.sender, _amount);
    }
```

Also to prevent future frontrun DOS.
Flashloan should send all leftover tokens to base connector as rewards for user

```solidity
    //post flashloan callback
    for (uint256 i = 0; i < tokens.length; i++) {
        tokens[i].safeTransfer(receiver, tokens[i].balanceOf(address(this)));
    }
```
