# `LiquidityAllocator.getQuoteSuggestions()` not spread liquidity evenly

**Impact: Medium**. Once pool available liquidity crosses ~1,000,000 USD and `tickCount` jumps from 10 to 100+, the allocator still caps output quotes at 10 and misallocates the remainder to the last quote. In practice, the last quote (highest rate) can hoard ~91% of liquidity instead of ~10%, so the on-chain order book no longer matches the intended even split.

**Description**:
The `LiquidityAllocator.getQuoteSuggestions()` library does not return *an array of suggested liquidity amounts for each quote* evenly when `tickCount > max quote suggestions`.

When tickCount is 10, it return array liquidity split by 10 evenly `[1,1,1,1,1,1,1,1,1,1]`

When tickCount is 100, it return array liquidity split by 100 `[1,1,1,1,1,1,1,1,1,91]`

If we have available liquidity of 100K. The last tick with highest lending rates will hold 91K of cash.

- TickCount is decided by `UpdateOrder._getTicks()`. When available liquidity by the pool > 1 million USD, it return tickCount = 100

```solidity
    function _getTicks(uint256 totalLiquidity, address oracle) internal view returns (uint16 ticksCount) {
        uint256 liquidityUSD = (totalLiquidity * IOracle(oracle).getLoanToUsdPrice());//loanUSD feed.latestAnswer * loanAdjustment = 1e12 * 1e18;

        if (liquidityUSD < 100 * 1e36) {//100 USDC?
            ticksCount = 1;
        } else if (liquidityUSD < 1e6 * 1e36) {// 1,000,000 USDC
            ticksCount = 10;
        } else if (liquidityUSD < 1e8 * 1e36) {// 100,000,000 USDC
            ticksCount = 100;
        } else {
            ticksCount = 1000;
        }
    }

```

- `LiquidityAllocator.getQuoteSuggestions` take 100 tickCount and try to split liquidity by 100.
- But max quote Suggestions is cap by 10.
- Then `getQuoteSuggestions()` try to add liquidity/100 to quoteSuggestions array one by one, until last index they allocate the rest of liquidity split by 100 which is 91% of liquidity.

```solidity
    function getQuoteSuggestions(PoolStorage.PoolState storage s, uint16 tickCount, uint256 availableLiquidity)
        internal
        view
        returns (uint64[] memory rates, uint256[] memory liquidity)
    {
        uint16 quoteSuggestions = tickCount > 10 ? PoolConstants.QUOTE_SUGGESTIONS : tickCount;//always max 10 suggestions. ticks can grow to 1000 though
        rates = new uint64[](quoteSuggestions);
        liquidity = new uint256[](quoteSuggestions);
        uint256 currentUtilization = availableLiquidity == 0
            ? PoolConstants.MAX_UTILIZATION 
            : (s.totalBorrowAssets * PoolConstants.MAX_UTILIZATION) / s.totalSupplyAssets;

        uint256 utilizationPerTick = (PoolConstants.MAX_UTILIZATION - currentUtilization) / tickCount;
        uint256 liquidityPerTick = availableLiquidity / tickCount;
//@tickCount cap to max 10. it can only be 1 or 10. tick>1000 rounded down to 10
        // Track how much liquidity has been allocated
        uint256 allocatedLiquidity = 0;//@audit M01 liquidity per tick and utilization should be / quoteSuggestions not tickCount. Tick can be 1000, while quote is 10. This make first 9 tick lending small amount while the rest split big amount of liquidity token to last tick.

        for (uint256 i; i < quoteSuggestions; ++i) {
            uint256 startUtil = currentUtilization + uint256(i * utilizationPerTick);
            rates[i] = IIrm(s.config.irm).computeBorrowRate(PoolConstants.MAX_UTILIZATION, startUtil);
            // If this is the last tick, allocate all remaining liquidity
            if (i == quoteSuggestions - 1) {
                liquidity[i] = availableLiquidity - allocatedLiquidity;
            } else {
                liquidity[i] = liquidityPerTick;
                allocatedLiquidity += liquidityPerTick;
            }
            console.log("Index: %s, Liquidity: %e", i, liquidity[i]);
        }
    }

```

**Recommended Mitigation**:
`utilizationPerTick` and  `liquidityPerTick` should be divided by `quoteSuggestions`

```solidity
library LiquidityAllocator {

    function getQuoteSuggestions(PoolStorage.PoolState storage s, uint16 tickCount, uint256 availableLiquidity)
        internal
        view
        returns (uint64[] memory rates, uint256[] memory liquidity)
    {
        ...
        // uint256 utilizationPerTick = (PoolConstants.MAX_UTILIZATION - currentUtilization) / tickCount; // @can be abused to zero
        // uint256 liquidityPerTick = availableLiquidity / tickCount;
        uint256 utilizationPerTick = (PoolConstants.MAX_UTILIZATION - currentUtilization) / quoteSuggestions;
        uint256 liquidityPerTick = availableLiquidity / quoteSuggestions;
        ...
    }
}
```

### POC

POC file test show library not return liquidity evenly.
Add this to line 42 in `LiquidityAllocator.sol`
`console.log("Index: %s, Liquidity: %e", i, liquidity[i]);`
If include console log to Library `LiquidityAllocator.sol` directly. It is much easier to debug it.

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

import "./BasePoolTest.t.sol";
import {PoolStorage} from "../src/pool/PoolStorage.sol";
import {PoolGetter} from "../src/pool/utils/PoolGetter.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {LiquidityAllocator} from "../src/libraries/LiquidityAllocator.sol";
import {console} from "forge-std/console.sol";

/**
 * @title POC Test Suite
 * @notice This contract contains Proof of Concept tests for the Avon Periphery protocol
 * @dev Built on top of BasePoolTest which provides:
 *      - 3 pools (pool, pool1, pool2) with different LTV configurations (80%, 90%, 70%)
 *      - Mock tokens: loanToken (MockUSDC) and collateralToken (MyToken)
 *      - Mock oracle and interest rate model
 *      - Pre-configured users: owner, lender1, lender2, borrower, liquidator, manager
 *      - Helper functions for setting up lending/borrowing positions
 */
contract POC_Test is BasePoolTest {
    function setUp() public override {
        // The BasePoolTest.setUp() provides the complete test environment:
        // - Deploys and configures 3 pools with different LTV ratios
        // - Sets up mock tokens, oracle, IRM, and orderbook
        // - Mints initial tokens to test users
        // - Whitelists pools in the orderbook
        super.setUp();

        // Additional POC-specific setup can be added here if needed
    }

    function test_POC() external {
        // Write your POC here
        console.log("- POC test -");
        //@1. 
        // Add console.log(liquidity[i]) to LiquidityAllocator.sol to see liquidity not spread evenly.

        //lending 1000 USDC
        console.log(" -- Lending 1,000 USDC-- ");
        _setupLendingPosition(lender1, 1_000e6);
        //Lending 100M USDC
        console.log(" -- Lending 1,000,000 USDC-- ");
        vm.prank(owner);
        loanToken.mint(lender1, 1_000_000e6);
        _setupLendingPosition(lender1, 1_000_000e6);



        //@2. Direct library testing just show last liquidity array bigger than other 9 liquidity
        PoolStorage.PoolState storage s = PoolStorage._state();
        console.log("- Library LiquidityAllocator test -");
        (uint256 availableLiquidity, uint16 ticksCount) = setPoolState(200_000e6, 150_000e6);
        console.log("-- Pool available liquidity: %e , ticks: %s", availableLiquidity, ticksCount);
        (uint64[] memory rates, uint256[] memory liquidity) =
            LiquidityAllocator.getQuoteSuggestions(s, ticksCount, availableLiquidity);
        console.log("Rates and liquidity for 10 ticks:");
        for (uint256 i = 0; i < rates.length; i++) {
            console.log("Rate: %e , Liquidity: %e", uint256(rates[i]) * 365 days, liquidity[i]);
        }


        (availableLiquidity, ticksCount) = setPoolState(1_260_000e6, 150_000e6);
        console.log("-- Pool available liquidity: %e , ticks: %s", availableLiquidity, ticksCount);
        (rates, liquidity) = LiquidityAllocator.getQuoteSuggestions(s, ticksCount, availableLiquidity);
        console.log("Rates and liquidity for 1000 ticks:");
        for (uint256 i = 0; i < rates.length; i++) {
            console.log("Rate: %e , Liquidity: %e", uint256(rates[i]) * 365 days, liquidity[i]);
        }
        console.log(
            "There is a problem with liquidity allocation library. It fails to distribute liquidity evenly across ticks."
        );
        assertLt(liquidity[9], liquidity[0] * 90, "Last tick liquidity should not exceed 90x first tick liquidity");
    }

    function setPoolState(uint256 totalSupplyAssets, uint256 totalBorrowAssets)
        internal
        returns (uint256 availableLiquidity, uint16 ticksCount)
    {
        PoolStorage.PoolState storage s = PoolStorage._state();
        s.totalBorrowAssets = totalBorrowAssets;
        s.totalSupplyAssets = totalSupplyAssets;
        s.config.irm = address(irm);
        availableLiquidity = s.totalSupplyAssets - s.totalBorrowAssets;

        //@code from UpdateOrders._getTicks()

        uint256 liquidityUSD = availableLiquidity * oracle.getLoanToUsdPrice();
        if (liquidityUSD < 100 * 1e36) {
            //100 USDC?
            ticksCount = 1;
        } else if (liquidityUSD < 1e6 * 1e36) {
            // 1,000,000 USDC
            ticksCount = 10;
        } else if (liquidityUSD < 1e8 * 1e36) {
            // 100,000,000 USDC
            ticksCount = 100;
        } else {
            ticksCount = 1000;
        }
    }
}

```
